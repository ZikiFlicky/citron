
.\" Manpage for ctr.
.TH man 1 "1 June 2017" "1.0" "CTR man page"
.SH NAME
ctr \- run a Citron program
.SH SYNOPSIS
ctr [PROGRAM]
.SH DESCRIPTION
Citron\*R is general purpose programming language for UNIX\*R-like operating systems.
.SH REFERENCE MANUAL
Citron has 5 literals:
.RS 4
.br
- Nil
.br
- Booleans (True, False)
.br
- Numbers (1, -2, 3.5)
.br
- Strings 'All Strings are UTF8!'
.br
- Code Blocks { parameters code }
.br

.RE
The following messages are part of the Core API of the Citron Programming Language:
.br
.BR.BR.BR

.B Nil
.nf
    
     Nil represents 'nothing' or NULL in other languages.
     Any object property that has not been assigned a value
     will contain Nil. Unlike some other programming languages
     Citron has no concept of 'undefined' or isset, Nil is actually the
     same as 'undefined' or not set.
    
     Literal:
    
     Nil
.fi
.BR.BR.BR

.B [Nil] isNil
.nf
    
     Nil always answers this message with a boolean object 'True'.
.fi
.BR.BR.BR

.B [Nil] toString
.nf
    
     Returns the string representation of Nil: 'Nil'.
.fi
.BR.BR.BR

.B [Nil] toNumber
.nf
    
     Returns the numerical representation of Nil: 0.
.fi
.BR.BR.BR

.B [Nil] toBoolean
.nf
    
     Returns the boolean representation of Nil: False.
.fi
.BR.BR.BR

.B Object
.nf
    
     This is the base object, the parent of all other objects.
     It contains essential object oriented programming features.
.fi
.BR.BR.BR

.B Object] new hiding:
.nf
    
    Creates a new Object hiding some parameters.
.fi
.BR.BR.BR

.B [Object] type
.nf
    
     Returns a string representation of the type of object.
.fi
.BR.BR.BR

.B [Object] toString
.nf
    
     Returns a string representation of a generic object.
     This string representation will be:
    
     [Object]
.fi
.BR.BR.BR

.B [Object] toNumber
.nf
    
     Returns a numerical representation of the object. This basic behavior, part
     of any object will just return 1. Other objects typically override this
     behavior with more useful implementations.
.fi
.BR.BR.BR

.B [Object] toBoolean
.nf
    
     Returns a boolean representation of the object. This basic behavior, part
     of any object will just return True. Other objects typically override this
     behavior with more useful implementations.
.fi
.BR.BR.BR

.B [Object] equals: [other]
.nf
    
     Tests whether the current instance is the same as
     the argument.
    
     Alias: =
    
     Usage:
     object equals: other
.fi
.BR.BR.BR

.B [Object] myself
.nf
    
     Returns the object itself.
.fi
.BR.BR.BR

.B [Object] learn: [String] means: [String].
.nf
    
     Teaches any object to repsond to the first specified message just like
     it would upon receiving the second. This allows you to map existing
     responses to new messages. You can use this to translate messages into your native
     language. After mapping, sending the alias message will be just as fast
     as sending the original message. You can use this to create programs
     in your native language without sacrficing performance. Of course the mapping itself
     has a cost, but the mapped calls will be 'toll-free'.
    
     Usage:
    
     #in this example we'll map a message to a Dutch word:
    
     Boolean learn: 'alsWaar:'
             means: 'ifTrue:'.
    
     (2 > 1) alsWaar: {
       Pen write: 'alsWaar means ifTrue in Dutch'.
     }
.fi
.BR.BR.BR

.B [Object] do
.nf
    
     Activates 'chain mode'. If chain mode is active, all messages will
     return the recipient object regardless of their return signature.
    
     Usage:
    
     a := Array < 'hello' ; 'world' ; True ; Nil ; 666.
     a do pop shift unshift: 'hi', push: 999, done.
    
     Because of 'chain mode' you can do 'a do pop shift' etc, instead of
    
     a pop.
     a shift.
     etc..
    
     The 'do' message tells the object to always return itself and disgard
     the original return value until the message 'done' has been received.
.fi
.BR.BR.BR

.B [Object] done
.nf
    
     Deactivates 'chain mode'.
.fi
.BR.BR.BR

.B [Object] message: [String] arguments: [Array]
.nf
    
     Sends a custom or 'dynamic' message to an object. This takes a string containing
     the message to be send to the object and an array listing the arguments at the
     correct indexes. If the array fails to provide the correct indexes this will
     generate an out-of-bounds error coming from the Array object. If something other
     than an Array is provided an error will be thrown as well.
    
     Usage:
    
     var str := 'write:'.
     Pen message: 'write:' arguments: (Array < 'Hello World').
    
     This will print the string 'Hello world' on the screen using a dynamically
     crafted message.
.fi
.BR.BR.BR

.B [Object] on: [String] do: [Block]
.nf
    
     Makes the object respond to a new kind of message.
     Use the semicolons to indicate the positions of the arguments to be
     passed.
    
     Usage:
    
     object on: 'greet' do: { ... }.
     object on: 'between:and:' do: { ... }.
    
.fi
.BR.BR.BR

.B [Object] respondTo: [String]
.nf
    
     Variations:
    
     [Object] respondTo: [String] with: [String]
     [Object] respondTo: [String] with: [String] and: [String]
    
     Default respond-to implemention, does nothing.
.fi
.BR.BR.BR

.B [Object] isNil
.nf
    
     Default isNil implementation.
    
     Always returns boolean object False.
.fi
.BR.BR.BR

.B Boolean
.nf
    
     Literal:
    
     True
     False
.fi
.BR.BR.BR

.B [Boolean] = [other]
.nf
    
     Tests whether the other object (as a boolean) has the
     same value (boolean state True or False) as the current one.
    
     Usage:
    
     (True = False) ifFalse: { Pen write: 'This is not True!'. }.
.fi
.BR.BR.BR

.B [Boolean] != [other]
.nf
    
     Tests whether the other object (as a boolean) has the
     same value (boolean state True or False) as the current one.
    
     Usage:
    
     (True != False) ifTrue: { Pen write: 'This is not True!'. }.
.fi
.BR.BR.BR

.B [Boolean] toString
.nf
    
     Simple cast function.
.fi
.BR.BR.BR

.B [Boolean] break
.nf
    
     Breaks out of the current block and bubbles up to the parent block if
     the value of the receiver equals boolean True.
    
     Usage:
    
     (iteration > 10) break. #breaks out of loop after 10 iterations
.fi
.BR.BR.BR

.B [Boolean] continue
.nf
    
     Skips the remainder of the current block in a loop, continues to the next
     iteration.
    
     Usage:
    
     (iteration > 10) continue.
.fi
.BR.BR.BR

.B [Boolean] ifTrue: [block]
.nf
    
     Executes a block of code if the value of the boolean
     object is True.
    
     Usage:
     (some expression) ifTrue: { ... }.
    
     You can also use ifFalse and ifTrue with other objects because the
     Object instance also responds to these messages.
.fi
.BR.BR.BR

.B [Boolean] ifFalse: [block]
.nf
    
     Executes a block of code if the value of the boolean
     object is True.
    
     Usage:
     (some expression) ifFalse: { ... }.
    
     You can also use ifFalse and ifTrue with other objects because the
     Object instance also responds to these messages.
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B [Boolean] not
.nf
    
     Returns the opposite of the current value.
    
     Usage:
     True := False not.
    
.fi
.BR.BR.BR

.B [Boolean] flip
.nf
    
     'Flips a coin'. Returns a random boolean value True or False.
    
     Usage:
     coinLandsOn := (Boolean flip).
.fi
.BR.BR.BR

.B [Boolean] either: [this] or: [that]
.nf
    
     Returns argument #1 if boolean value is True and argument #2 otherwise.
    
     Usage:
     Pen write: 'the coin lands on: ' + (Boolean flip either: 'head' or: 'tail').
.fi
.BR.BR.BR

.B [Boolean] & [other]
.nf
    
     Returns True if both the object value is True and the
     argument is True as well.
    
     Usage:
    
     a & b
    
.fi
.BR.BR.BR

.B [Boolean] ! [other]
.nf
    
     Returns True if the object value is False and the
     argument is False as well.
    
     Usage:
    
     a ! b
    
.fi
.BR.BR.BR

.B [Boolean] | [other]
.nf
    
     Returns True if either the object value is True or the
     argument is True or both are True.
    
     Usage:
    
     a | b
.fi
.BR.BR.BR

.B [Boolean] ? [other]
.nf
    
     Returns True if either the object value is True or the
     argument is True but not both.
    
     Usage:
    
     a ? b
.fi
.BR.BR.BR

.B [Boolean] toNumber
.nf
    
     Returns 0 if boolean is False and 1 otherwise.
.fi
.BR.BR.BR

.B Number
.nf
    
     Literal:
    
     0
     1
     -8
     2.5
    
     Represents a number object in Citron.
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B [Number] > [other]
.nf
    
     Returns True if the number is higher than other number.
.fi
.BR.BR.BR

.B [Number] >=: [other]
.nf
    
     Returns True if the number is higher than or equal to other number.
.fi
.BR.BR.BR

.B [Number] < [other]
.nf
    
     Returns True if the number is less than other number.
.fi
.BR.BR.BR

.B [Number] <=: [other]
.nf
    
     Returns True if the number is less than or equal to other number.
.fi
.BR.BR.BR

.B [Number] = [other]
.nf
    
     Returns True if the number equals the other number.
.fi
.BR.BR.BR

.B [Number] !=: [other]
.nf
    
     Returns True if the number does not equal the other number.
.fi
.BR.BR.BR

.B [Number] between: [low] and: [high]
.nf
    
     Returns True if the number instance has a value between the two
     specified values.
    
     Usage:
    
     q between: x and: y
.fi
.BR.BR.BR

.B [Number] odd
.nf
    
     Returns True if the number is odd and False otherwise.
.fi
.BR.BR.BR

.B [Number] even
.nf
    
     Returns True if the number is even and False otherwise.
.fi
.BR.BR.BR

.B [Number] + [Number]
.nf
    
     Adds the other number to the current one. Returns a new
     number object.
.fi
.BR.BR.BR

.B [Number] +=: [Number]
.nf
    
     Increases the number ITSELF by the specified amount, this message will change the
     value of the number object itself instead of returning a new number.
.fi
.BR.BR.BR

.B [Number] - [Number]
.nf
    
     Subtracts the other number from the current one. Returns a new
     number object.
.fi
.BR.BR.BR

.B [Number] -=: [number]
.nf
    
     Decreases the number ITSELF by the specified amount, this message will change the
     value of the number object itself instead of returning a new number.
.fi
.BR.BR.BR

.B [Number] * [Number or Block]
.nf
    
     Multiplies the number by the specified multiplier. Returns a new
     number object.
.fi
.BR.BR.BR

.B [Number] times: [Block]
.nf
    
     Runs the block of code a 'Number' of times.
     This is the most basic form of a loop.
    
     Usage:
    
     7 times: { :i Pen write: i. }.
    
     The example above runs the block 7 times. The current iteration
     number is passed to the block as a parameter (i in this example).
.fi
.BR.BR.BR

.B [Number] *=: [Number]
.nf
    
     Multiplies the number ITSELF by multiplier, this message will change the
     value of the number object itself instead of returning a new number.
    
     Usage:
    
     x := 5.
     x *=: 2. #x is now 10.
    
     Use this message to apply the operation to the object itself instead
     of creating and returning a new object.
.fi
.BR.BR.BR

.B [Number] / [Number]
.nf
    
     Divides the number by the specified divider. Returns a new
     number object.
.fi
.BR.BR.BR

.B [Number] /=: [Number]
.nf
    
     Divides the number ITSELF by divider, this message will change the
     value of the number object itself instead of returning a new number.
    
     Usage:
    
     x := 10.
     x /=: 2. #x will now be 5.
    
     Use this message to apply the operation to the object itself instead
     of generating a new object.
.fi
.BR.BR.BR

.B [Number] % [modulo]
.nf
    
     Returns the modulo of the number. This message will return a new
     object representing the modulo of the recipient.
    
     Usage:
    
     x := 11 % 3. #x will now be 2
    
     Use this message to apply the operation of division to the
     object itself instead of generating a new one.
.fi
.BR.BR.BR

.B [Number] toPowerOf: [power]
.nf
    
     Returns a new object representing the
     number to the specified power.
    
     Usage:
    
     x := 2 toPowerOf: 8. #x will be 256
    
     The example above will raise 2 to the power of 8 resulting in
     a new Number object: 256.
.fi
.BR.BR.BR

.B [Number] pos
.nf
    
     Returns a boolean indicating wether the number is positive.
     This message will return a boolean object 'True' if the recipient is
     positive and 'False' otherwise.
    
     Usage:
    
     hope := 0.1.
     ( hope pos ) ifTrue: { Pen write: 'Still a little hope for humanity'. }.
    
     The example above will print the message because hope is higher than 0.
.fi
.BR.BR.BR

.B [Number] neg
.nf
    
     Returns a boolean indicating wether the number is negative.
     This message will return a boolean object 'True' if the recipient is
     negative and 'False' otherwise. It's the eaxct opposite of the 'positive'
     message.
    
     Usage:
    
     hope := -1.
     (hope neg) ifTrue: { Pen write: 'No hope left'. }.
    
     The example above will print the message because the value of the variable
     hope is less than 0.
.fi
.BR.BR.BR

.B [Number] max: [other]
.nf
    
     Returns the biggest number of the two.
    
     Usage:
    
     x := 6 max: 4. #x is 6
     x := 6 max: 7. #x is 7
.fi
.BR.BR.BR

.B [Number] min: [other]
.nf
    
     Returns a the smallest number.
    
     Usage:
    
     x := 6 min: 4. #x is 4
     x := 6 min: 7. #x is 7
.fi
.BR.BR.BR

.B [Number] factorial
.nf
    
     Calculates the factorial of a number.
.fi
.BR.BR.BR

.B [Number] to: [number] step: [step] do: [block]
.nf
    
     Runs the specified block for each step it takes to go from
     the start value to the target value using the specified step size.
     This is basically how you write for-loops in Citron.
    
     Usage:
    
     1 to: 5 step: 1 do: { :step Pen write: 'this is step #'+step. }.
.fi
.BR.BR.BR

.B [Number] floor
.nf
    
     Gives the largest integer less than the recipient.
    
     Usage:
    
     x := 4.5
     y := x floor. #y will be 4
    
     The example above applies the floor function to the recipient (4.5)
     returning a new number object (4).
.fi
.BR.BR.BR

.B [Number] ceil
.nf
    
     Rounds up the recipient number and returns the next higher integer number
     as a result.
    
     Usage:
    
     x := 4.5.
     y = x ceil. #y will be 5
    
     The example above applies the ceiling function to the recipient (4.5)
     returning a new number object (5).
.fi
.BR.BR.BR

.B [Number] round
.nf
    
     Returns the rounded number.
.fi
.BR.BR.BR

.B [Number] abs
.nf
    
     Returns the absolute (unsigned, positive) value of the number.
    
     Usage:
    
     x := -7.
     y := x abs. #y will be 7
    
     The example above strips the sign off the value -7 resulting
     in 7.
.fi
.BR.BR.BR

.B [Number] sqrt
.nf
    
     Returns the square root of the recipient.
    
     Usage:
    
     x := 49.
     y := x sqrt. #y will be 7
    
     The example above takes the square root of 49, resulting in the
     number 7.
.fi
.BR.BR.BR

.B [Number] exp
.nf
    
     Returns the exponent of the number.
.fi
.BR.BR.BR

.B [Number] sin
.nf
    
     Returns the sine of the number.
.fi
.BR.BR.BR

.B [Number] cos
.nf
    
     Returns the cosine of the number.
.fi
.BR.BR.BR

.B [Number] tan
.nf
    
     Caculates the tangent of a number.
.fi
.BR.BR.BR

.B [Number] atan
.nf
    
     Caculates the arctangent of a number.
.fi
.BR.BR.BR

.B [Number] log
.nf
    
     Calculates the logarithm of a number.
.fi
.BR.BR.BR

.B [Number] toByte
.nf
    
     Converts a number to a single byte.
.fi
.BR.BR.BR

.B [Number] toString
.nf
    
     Wrapper for cast function.
.fi
.BR.BR.BR

.B [Number] toBoolean
.nf
    
     Casts a number to a boolean object.
.fi
.BR.BR.BR

.B String
.nf
    
     Literal:
    
     'Hello World, this is a String.'
    
     A sequence of characters. In Citron, strings are UTF-8 aware.
     You may only use single quotes. To escape a character use the
     backslash '\\' character.
    
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B [String] bytes
.nf
    
     Returns the number of bytes in a string, as opposed to
     length which returns the number of UTF-8 code points (symbols or characters).
.fi
.BR.BR.BR

.B [String] = [other]
.nf
    
     Returns True if the other string is the same (in bytes).
.fi
.BR.BR.BR

.B [String] != [other]
.nf
    
     Returns True if the other string is not the same (in bytes).
.fi
.BR.BR.BR

.B [String] length
.nf
    
     Returns the length of the string in symbols.
     This message is UTF-8 unicode aware. A 4 byte character will be counted as ONE.
.fi
.BR.BR.BR

.B [String] + [other]
.nf
    
     Appends other string to self and returns the resulting
     string as a new object.
.fi
.BR.BR.BR

.B [String] append: [String].
.nf
    
     Appends the specified string to itself. This is different from the '+'
     message, the '+' message adds the specified string while creating a new string.
     Appends on the other hand modifies the original string.
    
     Usage:
    
     x := 'Hello '.
     x append: 'World'.
     Pen write: x. #Hello World
    
     Instead of using the append message you may also use its short form,
     like this:
    
     x +=: 'World'.
.fi
.BR.BR.BR

.B [String] from: [position] to: [destination]
.nf
    
     Returns a portion of a string defined by from-to values.
     This message is UTF-8 unicode aware.
    
     Usage:
    
     'hello' from: 2 to: 3. #ll
.fi
.BR.BR.BR

.B [String] from: [start] length: [length]
.nf
    
     Returns a portion of a string defined by from
     and length values.
     This message is UTF-8 unicode aware.
    
     Usage:
    
     'hello' from: 2 length: 3. #llo
.fi
.BR.BR.BR

.B [String] skip: [number]
.nf
    
     Returns a string without the first X characters.
.fi
.BR.BR.BR

.B [String] at: [position]
.nf
    
     Returns the character at the specified position (UTF8 aware).
     You may also use the alias '@'.
    
     Usage:
    
     ('hello' at: 2). #l
     ('hello' @ 2). #l
.fi
.BR.BR.BR

.B [String] byteAt: [position]
.nf
    
     Returns the byte at the specified position (in bytes).
     Note that you cannot use the '@' message here because that will
     return the unicode point at the specified position, not the byte.
    
     Usage:
     ('abc' byteAt: 1). #98
.fi
.BR.BR.BR

.B [String] indexOf: [subject]
.nf
    
     Returns the index (character number, not the byte!) of the
     needle in the haystack.
    
     Usage:
    
     'find the needle' indexOf: 'needle'. #9
    
.fi
.BR.BR.BR

.B [String] asciiUpperCase
.nf
    
     Returns a new uppercased version of the string.
     Note that this is just basic ASCII case functionality, this should only
     be used for internal keys and as a basic utility function. This function
     DOES NOT WORK WITH UTF8 characters !
.fi
.BR.BR.BR

.B [String] asciiLowerCase
.nf
    
     Returns a new lowercased version of the string.
     Note that this is just basic ASCII case functionality, this should only
     be used for internal keys and as a basic utility function. This function
     DOES NOT WORK WITH UTF8 characters !
.fi
.BR.BR.BR

.B [String] asciiLowerCase1st
.nf
    
     Converts the first character of the recipient to lowercase and
     returns the resulting string object.
.fi
.BR.BR.BR

.B [String] asciiUpperCase1st
.nf
    
     Converts the first character of the recipient to uppercase and
     returns the resulting string object.
.fi
.BR.BR.BR

.B [String] lastIndexOf: [subject]
.nf
    
     Returns the index (character number, not the byte!) of the
     needle in the haystack.
    
     Usage:
    
     'find the needle' lastIndexOf: 'needle'. #9
.fi
.BR.BR.BR

.B [String] replace: [string] with: [other]
.nf
    
     Replaces needle with replacement in original string and returns
     the result as a new string object.
    
     Usage:
    
     'LiLo BootLoader' replace: 'L' with: 'l'. #lilo Bootloader
.fi
.BR.BR.BR

.B [String] findPattern: [String] do: [Block] options: [String].
.nf
    
     Matches the POSIX regular expression in the first argument against
     the string and executes the specified block on every match passing
     an array containing the matches.
    
     The options parameter can be used to pass specific flags to the
     regular expression engine. As of the moment of writing this functionality
     has not been implemented yet. The only flag you can set at this moment is
     the 'ignore' flag, just a test flag. This flag does not execute the block.
    
     Usage:
    
     'hello world' findPattern: '([hl])' do: { :arr
      Pen write: (arr join: '|'), brk.
     } options: ''.
    
     On every match the block gets executed and the matches are
     passed to the block as arguments. You can also use this feature to replace
     parts of the string, simply return the replacement string in your block.
.fi
.BR.BR.BR

.B [String] findPattern: [String] do: [Block].
.nf
    
     Same as findPattern:do:options: but without the options, no flags will
     be send to the regex engine.
.fi
.BR.BR.BR

.B [String] contains: [String]
.nf
    
     Returns True if the other string is a substring.
.fi
.BR.BR.BR

.B [String] containsPattern: [String].
.nf
    
     Tests the pattern against the string and returns True if there is a match
     and False otherwise.
    
     Usage:
    
     var match := 'Hello World' containsPattern: '[:space:]'.
     #match will be True because there is a space in 'Hello World'
.fi
.BR.BR.BR

.B [String] trim
.nf
    
     Trims a string. Removes surrounding white space characters
     from string and returns the result as a new string object.
    
     Usage:
    
     ' hello ' trim. #hello
    
     The example above will strip all white space characters from the
     recipient on both sides of the text. Also see: leftTrim and rightTrim
     for variations of this message.
.fi
.BR.BR.BR

.B [String] leftTrim
.nf
    
     Removes all the whitespace at the left side of the string.
    
     Usage:
    
     message := ' hello world  '.
     message leftTrim.
    
     The example above will remove all the whitespace at the left of the
     string but leave the spaces at the right side intact.
.fi
.BR.BR.BR

.B [String] rightTrim
.nf
    
     Removes all the whitespace at the right side of the string.
    
     Usage:
    
     message := ' hello world  '.
     message rightTrim.
    
     The example above will remove all the whitespace at the right of the
     string but leave the spaces at the left side intact.
.fi
.BR.BR.BR

.B [String] toNumber
.nf
    
     Converts string to a number.
.fi
.BR.BR.BR

.B [String] toBoolean
.nf
    
     Converts string to boolean
.fi
.BR.BR.BR

.B [String] split: [String]
.nf
    
     Converts a string to an array by splitting the string using
     the specified delimiter (also a string).
.fi
.BR.BR.BR

.B [String] characters.
.nf
    
     Splits the string in UTF-8 characters and returns
     those as an array.
    
     Usage:
    
     a := 'abc' characters.
     a count. #3
.fi
.BR.BR.BR

.B [String] toByteArray
.nf
    
     Returns an array of bytes representing the string.
.fi
.BR.BR.BR

.B [String] appendByte: [Number].
.nf
    
     Appends a raw byte to a string.
.fi
.BR.BR.BR

.B [String] htmlEscape
.nf
    
     Escapes HTML chars.
.fi
.BR.BR.BR

.B [String] hashWithKey: [String]
.nf
    
     Returns the hash of the recipient String using the specified key.
     The default hash in Citron is the SipHash which is also used internally.
     SipHash can protect against hash flooding attacks.
.fi
.BR.BR.BR

.B [String] eval
.nf
    
     Evaluates the contents of the string as code.
     In contrast to other languages, an eval statement can only
     execute a very limited set of messages. Typically only Array and
     Map building can be performed using eval. Using eval in Citron can
     therefore be considered 'safe'.
    
     Usage:
    
     a := 'Array < 1 ; 2 ; 3' eval.
     x := a @ 2. #3
.fi
.BR.BR.BR

.B [String] escapeQuotes.
.nf
    
     Escapes all single quotes in a string. Sending this message to a
     string will cause all single quotes (') to be replaced with (\\').
.fi
.BR.BR.BR

.B [String] randomizeBytesWithLength: [Number].
.nf
    
     Returns a randomized string with the specified length using the pool of
     bytes contained in the String object.
.fi
.BR.BR.BR

.B Block
.nf
    
     Literal:
    
     { parameters (if any) here... code here... }
    
     each parameter has to be prefixed with
     a colon (:).
    
     Examples:
    
     { Pen write: 'a simple code block'. } run.
     { :param Pen write: param. } applyTo: 'write this!'.
     { :a :b ^ a + b. } applyTo: 1 and: 2.
     { :a :b :c ^ a + b + c. } applyTo: 1 and: 2 and: 3.
    
.fi
.BR.BR.BR

.B [Block] applyTo: [object]
.nf
    
     Runs a block of code using the specified object as a parameter.
     If you run a block using the messages 'run' or 'applyTo:', me/my will
     refer to the block itself instead of the containing object.
.fi
.BR.BR.BR

.B [Block] whileTrue: [block]
.nf
    
     Runs a block of code, depending on the outcome runs the other block
     as long as the result of the first one equals boolean True.
    
     Usage:
    
     x := 0.
     { ^(x < 6). } whileFalse:
     { x add: 1. }. #increment x until it reaches 6.
    
     Here we increment variable x by one until it reaches 6.
     While the number x is lower than 6 we keep incrementing it.
     Don't forget to use the return ^ symbol in the first block.
.fi
.BR.BR.BR

.B [Block] whileFalse: [block]
.nf
    
     Runs a block of code, depending on the outcome runs the other block
     as long as the result of the first one equals to False.
    
     Usage:
    
     x := 0.
     { ^(x > 5). }
     whileFalse: { x add: 1. }. #increment x until it reaches 6.
    
     Here we increment variable x by one until it reaches 6.
     While the number x is not higher than 5 we keep incrementing it.
     Don't forget to use the return ^ symbol in the first block.
.fi
.BR.BR.BR

.B [Block] run
.nf
    
     Sending the unary message 'run' to a block will cause it to execute.
     The run message takes no arguments, if you want to use the block as a function
     and send arguments, consider using the applyTo-family of messages instead.
     This message just simply runs the block of code without any arguments.
    
     Usage:
    
     { Pen write: 'Hello World'. } run. #prints 'Hello World'
    
     The example above will run the code inside the block and display
     the greeting.
.fi
.BR.BR.BR

.B [Block] set: [name] value: [object]
.nf
    
     Sets a variable in a block of code. This how you can get closure-like
     functionality.
    
     Usage:
    
     shout := { Pen write: (my message + '!!!'). }.
     shout set: 'message' value: 'hello'.
     shout run.
    
     Here we assign a block to a variable named 'shout'.
     We assign the string 'hello' to the variable 'message' inside the block.
     When we invoke the block 'shout' by sending the run message without any
     arguments it will display the string: 'hello!!!'.
    
     Similarly, you could use this technique to create a block that returns a
     block that applies a formula (for instance simple multiplication) and then set the
     multiplier to use in the formula. This way, you could create a block
     building 'formula blocks'. This is how you implement use closures
     in Citron.
.fi
.BR.BR.BR

.B [Block] error: [object].
.nf
    
     Sets error flag on a block of code.
     This will throw an error / exception.
     You can attach an object to the error, for instance
     an error message.
    
     Example:
    
     {
       thisBlock error: 'oops!'.
     } catch: { :errorMessage
       Pen write: errorMessage.
     }, run.
.fi
.BR.BR.BR

.B [Block] catch: [otherBlock]
.nf
    
     Associates an error clause to a block.
     If an error (exception) occurs within the block this block will be
     executed.
    
     Example:
    
     #Raise error on division by zero.
     {
        var z := 4 / 0.
     } catch: { :errorMessage
        Pen write: e, brk.
     }, run.
.fi
.BR.BR.BR

.B [Block] toString
.nf
    
     Returns a string representation of the Block. This basic behavior, part
     of any object will just return [Block]. Other objects typically override this
     behavior with more useful implementations.
.fi
.BR.BR.BR

.B [Array] new
.nf
    
     Creates a new Array.
    
     Usage:
    
     a := Array new.
    
     or, the short form:
    
     a := Array ← 1 ; 2 ; 3.  
    
     or (if you prefer ASCII only symbols):
    
     a := Array < 1 ; 2 ; 3.
    
.fi
.BR.BR.BR

.B [Array] type
.nf
    
     Returns the string 'Array'.
    
.fi
.BR.BR.BR

.B [Array] push: [Element]
.nf
    
     Pushes an element on top of the array.
    
     Usage:
    
     numbers := Array new.
     numbers push: 3.
.fi
.BR.BR.BR

.B [Array] min
.nf
    
     Returns the minimum value from an array.
    
     Usage:
    
     a := Array ← 8 ; 4 ; 2 ; 16.  
     m := a min. #2
    
.fi
.BR.BR.BR

.B [Array] max
.nf
    
     Returns the maximum value from an array.
    
     Usage:
    
     a := Array ← 8 ; 4 ; 2 ; 16.  
     m := a max. #16
    
.fi
.BR.BR.BR

.B [Array] sum
.nf
    
     Takes the sum of an array. This message will calculate the
     sum of the numerical elements in the array.
    
     Usage:
    
     a := Array ← 1 ; 2 ; 3.  
     s := a sum. #6
    
     In the example above, the sum of array will be stored in s and
     it's value will be 6.
.fi
.BR.BR.BR

.B [Array] product
.nf
    
     Takes the product of an array. On receiving this message, the
     Array recipient object will calculate the product of its
     numerical elements.
    
     Usage:
    
     a := Array ← 2 ; 4 ; 8.  
     p := a product. #64
    
     In the example above, the product of the array will be calculated
     because the array receives the message 'product'. The product of the elements
     ( 2 * 4 * 8 = 64 ) will be stored in p.
.fi
.BR.BR.BR

.B [Array] map: [Block].
.nf
    
     Iterates over the array. Passing each element as a key-value pair to the
     specified block.
     The map message will pass the following arguments to the block, the key,
     the value and a reference to the array itself. The last argument might seem
     redundant but allows for a more functional programming style.
    
     Usage:
    
     files map: showName.
     files map: {
       :key :filename :files
       Pen write: filename, brk.
     }.
.fi
.BR.BR.BR

.B [Array] each: [Block].
.nf
    
      Alias for [Array] map: [Block].
.fi
.BR.BR.BR

.B [Array] ← [Element1] ; [Element2] ; ...  
.nf
    
     Creates a new instance of an array and initializes this
     array with a first element, useful for literal-like Array
     notations.
    
     Usage:
    
     a := Array ← 1 ; 2 ; 3.  
    
     or if you like ASCII-only:
    
     a := Array < 1 ; 2 ; 3.
    
     Note that the ; symbol here is an alias for 'push:'.
.fi
.BR.BR.BR

.B [Array] unshift: [Element].
.nf
    
     Unshift operation for array.
     Adds the specified element to the beginning of the array.
    
     Usage:
    
     a := Array new.
     a push: 1.
     a unshift: 3. #now contains: 3,1
.fi
.BR.BR.BR

.B [Array] join: [Glue].
.nf
    
     Joins the elements of an array together in a string
     separated by a specified glue string.
    
     Usage:
    
     collection := Array new.
     collection push: 1, push: 2, push 3.
     collection join: ','. # results in string: '1,2,3'
.fi
.BR.BR.BR

.B [Array] at: [Index]
.nf
    
     Returns the element in the array at the specified index.
     Note that the fisrt index of the array is index 0.
    
     Usage:
    
     fruits := Array ← 'apples' ; 'oranges' ; 'bananas'.  
     fruits at: 1. #returns 'oranges'
.fi
.BR.BR.BR

.B [Array] @ [Index]
.nf
    
     Alias for [Array] at: [Index]
.fi
.BR.BR.BR

.B [Array] put: [Element] at: [Index]
.nf
    
     Puts a value in the array at the specified index.
     Array will be automatically expanded if the index is higher than
     the maximum index of the array.
    
     Usage:
    
     fruits := Array new.
     fruits put: 'apples' at: 5.
.fi
.BR.BR.BR

.B [Array] pop
.nf
    
     Pops off the last element of the array.
.fi
.BR.BR.BR

.B [Array] shift
.nf
    
     Shifts off the first element of the array.
.fi
.BR.BR.BR

.B [Array] count
.nf
    
     Returns the number of elements in the array.
.fi
.BR.BR.BR

.B [Array] from: [Begin] length: [End]
.nf
    
     Copies part of an array indicated by from and to and
     returns a new array consisting of a copy of this region.
.fi
.BR.BR.BR

.B [Array] + [Array]
.nf
    
     Returns a new array, containing elements of itself and the other
     array.
.fi
.BR.BR.BR

.BR.BR.BR

.B [Array] sort: [Block]
.nf
    
     Sorts the contents of an array using a sort block.
     Uses qsort.
.fi
.BR.BR.BR

.B [Array] toString
.nf
    
     Returns a string representation of the array and its contents.
     This representation will be encoded in the Citron language itself and is
     therefore evallable.
    
     Usage:
    
     a := Array ← 'hello' ; 'world'.  
     b := a toString.
     c := b eval.
     x := c @ 1. #world
    
     toString messages are implicitly send by some objects, for instance when
     attempting to write an Array using a Pen.
    
     You can also use the alias 'serialize'.
.fi
.BR.BR.BR

.B [Array] serialize
.nf
    
     Alias for [Array] toString.
    
     See 'Map serialize' for the reason for this alias.
.fi
.BR.BR.BR

.B Map
.nf
    
     Creates a Map object.
    
     Usage:
    
     files := Map new.
     files put: 'readme.txt' at: 'textfile'.
.fi
.BR.BR.BR

.B [Map] type
.nf
    
     Returns the string 'Map'.
    
.fi
.BR.BR.BR

.B [Map] put: [Element] at: [Key]
.nf
    
     Puts a key-value pair in a map.
    
     Usage:
    
     map put: 'hello' at: 'world'.
    
.fi
.BR.BR.BR

.B [Map] at: [Key]
.nf
    
     Retrieves the value specified by the key from the map.
.fi
.BR.BR.BR

.B [Map] @ [Key]
.nf
    
     Alias for [Map] at: [Key].
    
.fi
.BR.BR.BR

.B [Map] count
.nf
    
     Returns the number of elements in the map.
.fi
.BR.BR.BR

.B [Map] each: [Block]
.nf
    
     Iterates over the map, passing key-value pairs to the specified block.
     Note that within an each/map block, 'me' and 'my' refer to the collection.
.fi
.BR.BR.BR

.B [Map] toString
.nf
    
     Returns a string representation of a map encoded in Citron itself.
     This will give you an
     evallable representation of the map and all of its members.
    
     Usage
    
     m := (Map new) put: 'hello' at: 'world'.
     x := m toString
     m := x eval.
    
     The toString method is automatically invoked when attempting to
     print a Map:
    
     Pen write: (Map new). #prints Map new.
    
     You can also use the alias 'serialize'.
.fi
.BR.BR.BR

.B [Map] serialize
.nf
    
     Alias for [Map] toString.
     A toString message, sometimes implicitly send by other messages like
     'Pen write:' will give you a serialized version of the Map or Array.
     This is far more useful than a 'dumb' textual description of the object like
     'array' or 'object'. However, when working with very large Maps or Arrays
     accidentally dumping the entire contents can be annoying, in this case you can
     override the toString behaviour but you don't have to remap the original, you
     can just use this alias. Also, this alias can be used if you want to make
     the serialization more explicit.
.fi
.BR.BR.BR

.B File
.nf
    
     Represents a File object.
     Creates a new file object based on the specified path.
    
     Usage:
    
     File new: '/example/path/to/file.txt'.
.fi
.BR.BR.BR

.B [File] tempFileLike: [String]
.nf
    
     Represents a File object.
     Creates a new temporary file object based on the specified path.
     replacing XXXX with some chars.
     Usage:
    
     File tempFileLike: '/example/path/to/fileXXXXXXXX.txt'.
.fi
.BR.BR.BR

.B [File] path
.nf
    
     Returns the path of a file. The file object will respond to this
     message by returning a string object describing the full path to the
     recipient.
.fi
.BR.BR.BR

.B [File] read
.nf
    
     Reads contents of a file. Send this message to a file to read the entire contents in
     one go. For big files you might want to prefer a streaming approach to avoid
     memory exhaustion (see readBytes etc).
    
     Usage:
    
     data := File new: '/path/to/mydata.csv', read.
    
     In the example above we read the contents of the entire CSV file callled mydata.csv
     in the variable called data.
.fi
.BR.BR.BR

.B [File] write: [String]
.nf
    
     Writes content to a file. Send this message to a file object to write the
     entire contents of the specified string to the file in one go. The file object
     responds to this message for convience reasons, however for big files it might
     be a better idea to use the streaming API if possible (see readBytes etc.).
    
     data := '<xml>hello</xml>'.
     File new: 'myxml.xml', write: data.
    
     In the example above we write the XML snippet in variable data to a file
     called myxml.xml in the current working directory.
.fi
.BR.BR.BR

.B [File] append: [String]
.nf
    
     Appends content to a file. The file object responds to this message like it
     responds to the write-message, however in this case the contents of the string
     will be appended to the existing content inside the file.
.fi
.BR.BR.BR

.B [File] exists
.nf
    
     Returns True if the file exists and False otherwise.
.fi
.BR.BR.BR

.B [File] include
.nf
    
     Includes the file as a piece of executable code.
.fi
.BR.BR.BR

.B [File] delete
.nf
    
     Deletes the file.
.fi
.BR.BR.BR

.B [File] size
.nf
    
     Returns the size of the file.
.fi
.BR.BR.BR

.B [File] open: [string]
.nf
    
     Open a file with using the specified mode.
    
     Usage:
    
     f := File new: '/path/to/file'.
     f open: 'r+'. #opens file for reading and writing
    
     The example above opens the file in f for reading and writing.
.fi
.BR.BR.BR

.B [File] close.
.nf
    
     Closes the file represented by the recipient.
    
     Usage:
    
     f := File new: '/path/to/file.txt'.
     f open: 'r+'.
     f close.
    
     The example above opens and closes a file.
.fi
.BR.BR.BR

.B [File] readBytes: [Number].
.nf
    
     Reads a number of bytes from the file.
    
     Usage:
    
     f := File new: '/path/to/file.txt'.
     f open: 'r+'.
     x := f readBytes: 10.
     f close.
    
     The example above reads 10 bytes from the file represented by f
     and puts them in buffer x.
.fi
.BR.BR.BR

.B [File] writeBytes: [String].
.nf
    
     Takes a string and writes the bytes in the string to the file
     object. Returns the number of bytes actually written.
    
     Usage:
    
     f := File new: '/path/to/file.txt'.
     f open: 'r+'.
     n := f writeBytes: 'Hello World'.
     f close.
    
     The example above writes 'Hello World' to the specified file as bytes.
     The number of bytes written is returned in variable n.
.fi
.BR.BR.BR

.B [File] seek: [Number].
.nf
    
     Moves the file pointer to the specified position in the file
     (relative to the current position).
    
     Usage:
    
     file open: 'r', seek: 10.
    
     The example above opens a file for reading and moves the
     pointer to position 10 (meaning 10 bytes from the beginning of the file).
     The seek value may be negative.
.fi
.BR.BR.BR

.B [File] rewind.
.nf
    
     Rewinds the file. Moves the file pointer to the beginning of the file.
    
     Usage:
    
     file open: 'r'.
     x := file readBytes: 10. #read 10 bytes
     file rewind.        #rewind, set pointer to begin again
     y := file readBytes: 10. #re-read same 10 bytes
    
     The example above reads the same sequence of 10 bytes twice, resulting
     in variable x and y being equal.
.fi
.BR.BR.BR

.B [File] end.
.nf
    
     Moves the file pointer to the end of the file. Use this in combination with
     negative seek operations.
    
     Usage:
    
     file open: 'r'.
     file end.
     x := file seek: -10, readBytes: 10.
    
     The example above will read the last 10 bytes of the file. This is
     accomplished by first moving the file pointer to the end of the file,
     then putting it back 10 bytes (negative number), and then reading 10
     bytes.
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B Broom
.nf
    
     GarbageCollector, to invoke use:
    
     [Broom] sweep.
.fi
.BR.BR.BR

.B [Broom] dust
.nf
    
     Returns the number of objects collected.
.fi
.BR.BR.BR

.B [Broom] objectCount
.nf
    
     Returns the total number of objects considered in the latest collect
     cycle.
.fi
.BR.BR.BR

.B [Broom] keptCount
.nf
    
     Returns the total number of objects that have been marked during the
     latest cycle and have therefore been allowed to stay in memory.
.fi
.BR.BR.BR

.B [Broom] keptAlloc
.nf
    
     Returns the amount of allocated memory.
.fi
.BR.BR.BR

.B [Broom] stickyCount
.nf
    
     Returns the total number of objects that have a sticky flag.
     These objects will never be removed.
.fi
.BR.BR.BR

.B [Broom] memoryLimit
.nf
    
     Sets the memory limit, if this limit gets exceeded the program will produce
     an out-of-memory error.
.fi
.BR.BR.BR

.B [Broom] mode: [Number]
.nf
    
     Selects mode of operation for GC.
    
     Available Modes:
     0 - No Garbage Collection
     1 - Activate Garbage Collector
     4 - Activate Garbage Collector for every single step (testing only)
.fi
.BR.BR.BR

.B [Shell] call: [String]
.nf
    
     Performs a Shell operation. The Shell object uses a fluid API, so you can
     mix shell code with programming logic. For instance to list the contents
     of a directory use:
    
     Shell ls
    
     This will output the contents of the current working directly, you
     can also pass keyword messages like so:
    
     Shell echo: 'Hello from the Shell!'.
    
     The example above will output the specified message to the console.
     Every message you send will be turned into a string and dispatched to
     the 'call:' message.
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B [Slurp] obtain.
.nf
     
     Obtains the string generated using the Slurp object.
     A Slurp object collects all messages send to it and flushes its buffer while
     returning the resulting string after an 'obtain' message has been received.
     
     Usage:
     
     Slurp hello world.
     Pen write: (Slurp obtain).
     
     This will output: 'hello world'.
     Use the Slurp object to integrate verbose shell commands, other programming languages
     (like SQL) etc into your main program without overusing strings.
     
     Example:
     
     query select: '*', from users where: 'id = 2'.
    
     Note that we can't use the = and * unfortunately right now
     because = is also a method in the main object. While * can be used
     theoretically, it expects an identifier, and 'from' is not a real
     identifier, it's just another unary message, so instead of using a binary
     * we simply use a keyword message select: with argument '*' and then
     proceed our SQL query with a comma (,) to chain the rest.
     This is an artifact of the fact that the DSL has to be embedded within
     the language of Citron. However even with these restrictions (some of which might be
     alleviated in future versions) it's quite comfortable and readable to interweave
     an external language in your Citron script code.
.fi
.BR.BR.BR

.B [Program] argument: [Number]
.nf
    
     Obtains an argument from the CLI invocation.
.fi
.BR.BR.BR

.B [Program] argCount
.nf
    
     Returns the number of CLI arguments passed to the script.
.fi
.BR.BR.BR

.B [Program] exit
.nf
     
     Exits program immediately.
.fi
.BR.BR.BR

.B [Program] env: [String]
.nf
    
     Returns the value of an environment variable.
    
     Usage:
    
     x := Command env: 'MY_PATH_VAR'.
.fi
.BR.BR.BR

.B [Program] env: [Key] val: [Value]
.nf
    
     Sets the value of an environment variable.
.fi
.BR.BR.BR

.B [Program] waitForInput
.nf
    
     Ask a question on the command-line, resumes program
     only after pressing the enter key.
     Only reads up to 100 characters.
    
     Usage:
    
     Pen write: 'What is your name ?'.
     x := Command waitForInput.
     Pen write: 'Hello ' + x + ' !', brk.
    
     The example above asks the user for his/her name and
     then displays the input received.
.fi
.BR.BR.BR

.B [Program] input.
.nf
    
     Reads all raw input from STDIN.
    
     Usage (for instance to read raw CGI post):
    
     post := Program input.
.fi
.BR.BR.BR

.BR.BR.BR

.B [Program] forbidShell
.nf
    
     This method is part of the security profiles feature of Citron.
     This will forbid the program to execute any shell operations. All
     external libraries and plugins are assumed to respect this setting as well.
    
     Usage:
    
     Program forbidShell.
.fi
.BR.BR.BR

.B [Program] forbidFileWrite
.nf
    
     This method is part of the security profiles feature of Citron.
     This will forbid the program to modify, create or delete any files. All
     external libraries and plugins are assumed to respect this setting as well.
    
     Usage:
    
     Program forbidFileWrite.
.fi
.BR.BR.BR

.B [Program] forbidFileRead
.nf
    
     This method is part of the security profiles feature of Citron.
     This will forbid the program to read any files. In fact this will prevent you from
     creating the file object at all.
     This will also prevent you from reading environment variables.
     All external libraries and plugins are assumed to respect this setting as well.
     Forbidding a program to read files also has the effect to forbid including other
     source files.
    
     Usage:
    
     Program forbidFileRead.
.fi
.BR.BR.BR

.B [Program] forbidInclude
.nf
    
     This method is part of the security profiles feature of Citron.
     This will forbid the program to include any other files. All
     external libraries and plugins are assumed to respect this setting as well.
    
     Usage:
    
     Program forbidInclude.
.fi
.BR.BR.BR

.B [Program] forbidFork.
.nf
.fi
.BR.BR.BR

.B [Program] remainingMessages: [Number]
.nf
    
     This method is part of the security profiles feature of Citron.
     This will initiate a countdown for the program, you can specify the maximum quota of
     messages the program may process, once this quota has been exhausted the program will
     be killed entirely (no exception).
    
     Usage:
    
     Program remainingMessages: 100.
.fi
.BR.BR.BR

.B [Program] flush.
.nf
    
     Flushes the STDOUT output buffer.
.fi
.BR.BR.BR

.B [Program] new: [Block].
.nf
    
     Forks the program into two programs.
     Creates another program that will run at the same time as the
     current program. Both the parent and the child will obtain a reference
     to the newly created program. The child will obtain a reference to
     itself passed as a parameter to the code block while the parent will
     obtain its version of the program instance as the return value of the
     new: message.
    
     Note that spawning a new program will leak memory.
     The file descriptors used to setup communication between parent and
     child will be removed when the main program ends but any newly created
     program will add a descriptor pair to the set. This is a limitation
     in the current implementation.
    
     Usage:
    
     child := Program new: { :program
     	Pen write: 'Child', brk.
     }.
     Pen write: 'Parent'.
.fi
.BR.BR.BR

.B [Command] message: [String].
.nf
    
     Sends a message to another program, i.e. a child or a parent that is
     running at the same time.
.fi
.BR.BR.BR

.B [Command] listen: [Block].
.nf
    
     Stops the current flow of the program and starts listening for
     messages from other programs that are running at the same time.
     Upon receiving a message, the specified block will be invocated
     and passed the message that has been received.
.fi
.BR.BR.BR

.B [Command] join
.nf
    
     Rejoins the program with the main program.
     This message will cause the current program to stop and wait
     for the child program to end.
.fi
.BR.BR.BR

.B Object fromComputer: [String]
.nf
    
     Creates a remote object from the server specified by the
     ip address.
.fi
.BR.BR.BR

.B Program port: [Number].
.nf
    
     Sets the port to use for remote connections.
.fi
.BR.BR.BR

.B Program connectionLimit: [Number].
.nf
    
     Sets the maximum number of connections and requests that will be
     accepted by the current program.
.fi
.BR.BR.BR

.B Program serve: [Object].
.nf
    
     Serves an object. Client programs can now communicate with this object
     and send messages to it.
.fi
.BR.BR.BR

.B [Dice] rollWithSides: [Number]
.nf
    
     Rolls the dice, generates a pseudo random number.
.fi
.BR.BR.BR

.B [Dice] roll
.nf
    
     Rolls a standard dice with 6 sides.
.fi
.BR.BR.BR

.B [Dice] rawRandomNumber
.nf
    
     Generates a random number, the traditional way (like rand()).
.fi
.BR.BR.BR

.B [Clock] wait
.nf
    
     Waits X seconds.
.fi
.BR.BR.BR

.B [Clock] new: [Number].
.nf
    
     Creates a new clock instance from a UNIX time stamp.
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B [Clock] like: [Clock]
.nf
    
     Syncs a clock. Copies the time AND zone from the other clock.
    
     Usage:
     clock := Clock new: timeStamp.
     copyClock := Clock new like: clock.
.fi
.BR.BR.BR

.B [Clock] zone: [String]
.nf
    
     Sets the time zone of the clock.
.fi
.BR.BR.BR

.B [Clock] zone
.nf
    
     Returns time zone of the clock.
.fi
.BR.BR.BR

.B [Clock] zone: [Number]
.nf
    
     Sets the year of the clock.
.fi
.BR.BR.BR

.B [Clock] zone: [Number]
.nf
    
     Sets the month of the clock.
.fi
.BR.BR.BR

.B [Clock] zone: [Number]
.nf
    
     Sets the day of the clock.
.fi
.BR.BR.BR

.B [Clock] zone: [Number]
.nf
    
     Sets the hour of the clock.
.fi
.BR.BR.BR

.B [Clock] zone: [Number]
.nf
    
     Sets the minute of the clock.
.fi
.BR.BR.BR

.B [Clock] zone: [Number]
.nf
    
     Sets the second of the clock.
.fi
.BR.BR.BR

.B [Clock] year
.nf
    
     Returns year of the clock.
.fi
.BR.BR.BR

.B [Clock] month
.nf
    
     Returns month of the clock.
.fi
.BR.BR.BR

.B [Clock] day
.nf
    
     Returns day of the clock.
.fi
.BR.BR.BR

.B [Clock] hour
.nf
    
     Returns hour of the clock.
.fi
.BR.BR.BR

.B [Clock] minute
.nf
    
     Returns minute of the clock.
.fi
.BR.BR.BR

.B [Clock] second
.nf
    
     Returns second of the clock.
.fi
.BR.BR.BR

.B [Clock] yearday
.nf
    
     Returns day number of the year.
.fi
.BR.BR.BR

.B [Clock] weekday
.nf
    
     Returns the week day number of the clock.
.fi
.BR.BR.BR

.B [Clock] time.
.nf
    
     Returns the UNIX time stamp representation of the time.
     Note: this is the time OF CREATION OF THE OBJECT. To get the actual time use:
    
     [Clock] new time.
.fi
.BR.BR.BR

.B [Clock] week
.nf
    
     Returns the week number of the clock.
.fi
.BR.BR.BR

.B [Clock] format: [String]
.nf
    
     Returns a string describing the date and time represented by the clock object
     according to the specified format. See strftime for format syntax details.
.fi
.BR.BR.BR

.B [Clock] toString
.nf
    
     Returns a string describing the date and time 
     represented by the clock object.
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B [Clock] add: [Number].
.nf
    
     Adds the number to the clock, updating its time accordingly.
     Note that this is typically used with a qualifier.
     If the qualifier is 'hours' the number is treated as hours and
     the specified number of hours will be added to the time.
    
     The Clock object understands the following qualifiers
     if the selected language is English:
    
     sec, second, seconds,
     min, minute, minutes,
     hrs, hour, hours,
     day, days,
     week, weeks,
     month, months,
     year, years
    
     Note that it does not matter which form you use, 2 hour means
     the same as 2 hours (plural).
    
     Usage:
    
     clock add: 3 minutes. #adds 3 minutes
     clock add: 1 hour.    #adds 1 hour
     clock add: 2 second.  #adds 2 seconds
.fi
.BR.BR.BR

.B [Clock] subtract: [Number].
.nf
    
     Same as '[Clock] add:' but subtracts the number instead of adding it to
     the clock's time.
.fi
.BR.BR.BR

.B [Clock] new
.nf
    
     Creates a new clock, by default a clock will be set to
     the UTC timezone having the current time.
.fi
.BR.BR.BR

.B [Pen] write: [String]
.nf
    
     Writes string to console. 
.fi
.BR.BR.BR

.B [Pen] brk
.nf
     
     Outputs a newline character.
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B Request get: [string]
.nf
    
     Returns the value of the specified GET parameter from the HTTP query string.
     For example if the query string of an url is: ?search=glasses
     then the value of:
    
     item := Request get: 'search'.
    
     would be 'glasses'.
.fi
.BR.BR.BR

.B Request getArray: [string].
.nf
    
     Returns an array of strings extracted from the query string.
     For example if the query string contains: ?option=a&option=b
    
     Request getArray: 'option'.
    
     will contain two elements: 'a' and 'b'. Note that
     this also works with array-like notation: ?option[]='a'&option[]=b:
    
     Request getArray: 'option[]'.
    
     will return the same array.
.fi
.BR.BR.BR

.B Request post: [string].
.nf
    
     Obtains a string from the HTTP POST payload. Just like 'get:' but for
     POST variables. See 'Request get:' for details.
.fi
.BR.BR.BR

.B Request postArray: [string].
.nf
    
     Obtains an array from the HTTP POST payload. Just like 'getArray:' but for
     POST variables. See 'Request getArray:' for details.
.fi
.BR.BR.BR

.B Request cookie: [string].
.nf
    
     Obtains a string from the HTTP COOKIE payload. Just like 'get:' but for
     COOKIE variables. See 'Request get:' for details.
.fi
.BR.BR.BR

.B Request cookieArray: [string].
.nf
    
     Obtains an array from the HTTP COOKIE payload. Just like 'getArray:' but for
     COOKIE variables. See 'Request getArray:' for details.
.fi
.BR.BR.BR

.B Request file: [string].
.nf
    
     Returns array containing the path to the uploaded temporay file (0) and
     the desired name of the uploaded file (1).
.fi
.BR.BR.BR

.B Request serverOption: [string] is: [string].
.nf
    
     Sets a server option, available server option for SCGI server include:
    
     - minidle, minimum number of idle processes
     - maxidle, maximum number of idle processes
     - maxproc, maximum number of processes
     - maxreq,  maximum number of concurrent requests to allow
    
     Usage:
    
     Request
      serverOption: 'minidle' is: 8,
      serverOption: 'maxreq'  is: 100.
    
     This sets the minimum number of idle processes to 8 and the
     maximum number of concurrent requests to 100, you can chain
     multiple options using a comma (,).
.fi
.BR.BR.BR

.B Request host: [string] listen: [string] pid: [string] callback: [block].
.nf
    
     Sets up Storm Server.
     Storm Server is an SCGI server. Both the Request Object Plugin and Storm Server
     are based on S. Losen's CCGI library (http://libccgi.sourceforge.net/doc.html)
     licensed LGPL.
    
     To set up a Storm Server, specify host (i.e. 'localhost'),
     a port to listen to (i.e. 9000) a pid file '/var/run/mypid.pid' and a
     callback block.
    
     Usage:
    
     Request host:'localhost' listen:4000 pid:'/var/run/storm.pid' callback: {
      Pen write: 'Content-type: text/html\\n\\n'.
      var fname  := Command env: 'DOCUMENT_URI'.
      var script := File new: '/var/www/webapp'+fname.
      script include.
     }.
    
     Here we set up a server listening to port 4000. The callback prints out
     the content type header. Then, we extract the DOCUMENT URI, i.e. '/hello.ctr'
     and map this to a path '/var/www/webapp/hello.ctr'
    
     By default there is no output buffering, either create another callback or
     simply override the '<' or 'Pen' object to buffer instead of outputting
     directly.
.fi
.BR.BR.BR


.SH BUGS
This is a preliminary version (< 1.0) of Citron, there might still be very serious bugs.
Please refrain from using this version in a production environment. This version of Citron
is still considered 'alpha' stage and cannot be expected to be reliable.

.SH AUTHOR
AnotherTest and the Citron Community (Nil)
