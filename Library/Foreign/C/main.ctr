import foreign_alias.
import ctype_common_types.

# CTypeCommonTypes
var FunctionThunk is Object new.
var LoadedLibrary is Object new.
var loadedFuncs is Map new.
LoadedLibrary on: 'initWithPath:obj:' do: {:path:obj
  my name is path.
  my symbol is obj.
}.
LoadedLibrary on: 'toString' do: {
  ^'LoadedLibrary<%s at: %s>' % [my name, my symbol].
}.
FunctionThunk on: 'initWithName:obj:cif:' do: {:name:sym:cif
  my name is name.
  my symbol is sym.
  my cif is cif.
}.
FunctionThunk on: 'toString' do: {
  ^'DefinedFunction<%s at: %s | CIF = %s>' % [my name, my symbol, my cif].
}.
FunctionThunk on: 'applyTo:' do: {:args
  ^my cif call: my symbol withArgs: args.
}.
var extern_define is {:path:symbol:return:argtypes
  var lib is (const loadedFuncs at: path) or: {^CTypes loadLibrary: path.}.
  const loadedFuncs put: lib at: path.
  var sym is lib message: symbol arguments: [].
  var cif is CIF new setABI: 0 return: (CTypeTypeMap at: return) argTypes: (argtypes fmap: {:v ^CTypeTypeMap at: v.}).
  ^[(const LoadedLibrary new initWithPath: path obj: lib), (const FunctionThunk new initWithName: symbol obj: sym cif: cif)].
}.
extern_define on: 'fromLibrary:loadFunction:return:argTypes:' do: (extern_define &method: 'applyTo:and:and:and:').
import export: extern_define as: 'extern_define'.
