### DEPRECATE v
Object on: 'mapmatch:' do: {:self:blkmap
  var ret is Nil.
  var done is False.
  blkmap each: ({:k:v
    ret is {
      self unpack: k.
      ^Reflect runHere: v forObject: thisBlock arguments: [].
    } run.
      done is True.
      done break.
  } catch: {}).
  done ifFalse: { thisBlock error: 'non-exhaustive Pattern match'. }.
  ^ret.
}.

var Matcher is Object new
  on: 'of:' do: {:obj
    ^me cnew: {
      matchee => obj.
      map => Map new.
    }.
  },
  on: 'match:do:' do: {:pat:blk
    my map put: blk at: pat.
  },
  on: 'match' do: {
    ^my matchee mapmatch: my map.
  }.
Object on: 'match:do:' do: {:self:pat:blk
  ^const Matcher of: self, match: pat do: blk.
}.
### DEPRECATE ^

Object on: 'match:' do: {:self:ast
  #ast -> $[
  # [$!(pattern), consequence],
  # [$!(pattern), consequence]
  # ...
  #]
  var done is True.
  var ret is Nil.
  var cblk is thisBlock.
  ast each_v: {:cc
    cc is $!(cc). #Parse the tuple
    done is True.
    ret is {
      self unpack: $!(cc head).
      ^Reflect runHere: (\:_ $!(cc last)) forObject: thisBlock arguments: [].
    } catch: {:e done is False. }, run.
    done break.
  }.
  done ifFalse: { cblk error: 'non-exhaustive pattern match'. }.
  ^ret.
}.
