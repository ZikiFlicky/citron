var Maybe is Object new
  on: 'just:' do: {:p
    ^Just cnew: {
      my value is p.
    }.
  },
  on: 'nothing' do: {
    ^Nothing.
  },
  on: 'unpack:' do: {:to
    var self is me.
    ^((me type) = (Just type)) & ((to type) = (Just type))
      either: {^{
        ^const self unwrap unpack: (const to unwrap).
      }.}
      or: {
        ^(self type) = (Nothing type) either: {
          ([(String type), (Nothing type)] contains: to type) ifFalse: {
            thisBlock error: ('%s cannot be constructed by %s' % [(Reflect strTypeOf: to), (Reflect strTypeOf: const self)]).
          }.
          Reflect set: to to: Nothing.
          ^Nothing.
        } or: {
          thisBlock error: ('%s cannot be constructed by %s' % [(Reflect strTypeOf: to), (Reflect strTypeOf: const self)]).
        }.
      }.
  },
  on: 'equals:' do: {:other
    var self is me.
    ^(me type) = (var tt is other type)
      either: {
        ^tt = (Nothing type) either: True or: {^(self unwrap) = (other unwrap).}.
        }
      or: False.
  },
  on: 'isJust' do: {
    ^(me type) = (Just type).
  },
  learn: '=' means: 'equals:'.
var Just is Maybe cnew: { value => Nil. },
  on: '$' do: {:v
    ^me cnew: {
      my value is v.
    }.
  },
  on: 'type' do: {
    ^'Maybe#Just'.
  },
  on: 'toString' do: {\
    'Just $ (%s)' % [my value].
  },
  on: 'unwrap' do: {\ my value }.
var Nothing is Maybe new
  on: 'type' do: {
      ^'Maybe#Nothing'.
  },
  on: 'toString' do: {\ 'Nothing' }.
import
  export: Nothing as: 'Nothing',
  export: Just as: 'Just',
  export: Maybe as: 'Maybe'.
