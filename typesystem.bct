var TypeSystem is Object new.
var TypeSystem$Int is Object new.
var TypeSystem$Char is Object new.
var TypeSystem$Float is Object new.
var TypeSystem$Boolean is Object new.
var TypeSystem$Applicative is Object new.
var TypeSystem$Array is Object new.

TypeSystem$Array on: 'setType:' do: {:type my type is type.}.
TypeSystem$Array on: 'of:' do: {:type
  ^me new setType: type.
}.

TypeSystem$Applicative on: 'setFrom:to:' do: {:a:b
  my from is a.
  my to is b.
}.
TypeSystem$Applicative on: 'from:to:' do: {:a:b
  ^me new setFrom: a to: b.
}.

TypeSystem$Int on: 'type' do: {^'TSInt'.}.
TypeSystem$Char on: 'type' do: {^'TSChar'.}.
TypeSystem$Float on: 'type' do: {^'TSFloat'.}.
TypeSystem$Boolean on: 'type' do: {^'TSBoolean'.}.
TypeSystem$Array on: 'type' do: {^'[%s]' formatObjects: [(my type type)].}.
TypeSystem$Applicative on: 'type' do: {^'(%s->%s)' formatObjects: [(my from type), (my to type)].}.

TypeSystem on: 'Int' do: {^TypeSystem$Int.}.
TypeSystem on: 'Char' do: {^TypeSystem$Char.}.
TypeSystem on: 'Float' do: {^TypeSystem$Float.}.
TypeSystem on: 'Boolean' do: {^TypeSystem$Boolean.}.
TypeSystem on: 'respondTo:' do: {:sel
  var ret is me.
  1 times: {
    sel findPattern: '^\\!(.*?)\\|$' do: {:parts
      Pen write: 'arr ' + (parts), brk.
      ret is TypeSystem$Array of: (TypeSystem message: parts @ 1 arguments: Array).
      True break.
      ^''.
    }.
    sel findPattern: '^((?:\\!.*\\|)|(?:[^(->)]*))->(.*)$' do: {:parts
      Pen write: 'appl ' + (parts), brk.
      ret is TypeSystem$Applicative from: (TypeSystem message: parts @ 1 arguments: Array) to: (TypeSystem message: parts @ (parts count > 2 either: 3 or: 1) arguments: Array).
      True break.
      ^''.
      }.
  }.
  ^ret.
}.

ra is TypeSystem Int.
rb is TypeSystem !Char->!Int||->Int.
Pen write: rb type, brk.
