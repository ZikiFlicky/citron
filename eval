#!/usr/bin/env ctr
#
Broom autoAlloc: True.
contextPurity is False. #This is not a pure context, since objects are mutated in-between evaluations. so disallowing purely functional things.
#Pen write: 'Extensions: ' + (File extensionsPath), brk.
File new: (File extensionsPath) + '/extensions/fileutils.ctr', include.

inp is ''.

ImportLib Queue.
ImportLib LRArray.
import Library/Data/Map Library/Utils/Highlight Library/Utils/OneGateFlipper Library/Control/MethodResolve.

TerminalWidth is 85.

Eval is Object new.
Eval on: 'init' do: {
  my end is False.
  my color is 'resetColor'.
  my prompt is '>>> '.
  my args is Array new.
  my allowedColors is ('red blue magenta cyan yellow green resetColor' split: ' ') join: '|'.
  my evalQueue is Queue new.
  my globalvars is False.
  my history is LRArray new init: 100.
  my hs_file is File new: '~/.ctrhist'.
  my hs_file exists ifFalse: { my hs_file write: '[]'. }.
  (JSON parse: my hs_file read genericType: Object) each_v: (my history::'push:').
  my commands is Nil.
  my continuation is '...'.
  my flags is Map new
    put: True at: 'printvs',
    put: True at: 'highlight',
    put: False at: 'equit'.
  me genReader: 'eServer'.
  ^me.
}.
Eval on: 'handleException:' do: {:e
  ^me getFlag: 'equit', either: {thisBlock error: e.} or: {Pen red write: e, resetColor brk. ^e.}.
}.
Eval on: 'end' do: {
  my end is True.
  me stopEvalServer.
  my hs_file write: (JSON serialize: my history, =~: ?>s/\\([^"\\])/\\\\$1/g<?).
}.
Eval on: 'break' do: { my end ifTrue: {Broom sweep.}. ^my end. }.
Eval on: 'allowedColors' do: { ^my allowedColors. }.
Eval on: 'isAllowedColor:' do: { :c
  ^(c containsPattern: my allowedColors).
}.
Eval on: 'setColor:' do: { :c
  (me isAllowedColor: c) ifFalse: { thisBlock error: 'value $$c' + ' is not an allowed color.'. }.
  my color is c.
}.
Eval on: 'setPrompt:' do: { :p my prompt is p. }.
Eval on: 'setContinuation:' do: { :p my continuation is p. }.
Eval on: 'setArgs:' do: { :a my args := a. }.
Eval on: 'color' do: { ^my color. }.
Eval on: 'prompt' do: { ^my prompt. }.
Eval on: 'continuation' do: { ^my continuation. }.
Eval on: 'shiftArgs' do: { ^(my args shift). }.
Eval on: 'enableFlag:' do: {:flag my flags put: True at: flag. }.
Eval on: 'disableFlag:' do: {:flag my flags put: False at: flag. }.
Eval on: 'getFlag:' do: {:flag ^my flags at: flag. }.
Eval on: 'flags' do: {^my flags. }.
Eval on: 'modifyFlags:' do: {:flag
  flag startsWith: 'no-', ifTrue: {
    me disableFlag: (flag skip: 3).
  }, else: {
    me enableFlag: flag.
  }.
}.
Eval on: 'argCount' do: { ^(my args count). }.
Eval on: 'onlyRelevantArgs' do: { my args do shift shift done. }. #get rid of ./ctr eval

Eval on: 'startEvalServer' do: {
  var port is 5000 + (Dice rollWithSides: 1000).

  var EvalServer is Object new.
  EvalServer on: 'evaluate:' do: {:str
      ^str eval.
  }.

  my eServer is Program new: {:p
      p port: port.
      p serve: EvalServer.
  }.

  ^port.
}.

Eval on: 'startEvalServerOnPort:' do: {:port

  var EvalServer is Object new.
  EvalServer on: 'evaluate:' do: {:str
      ^str eval.
  }.

  my eServer is Program new: {:p
      p port: port.
      p serve: EvalServer.
  }.

  ^port.
}.

Eval on: 'stopEvalServer' do: {
  ^my eServer isNil not either: {my eServer signal: 1. ^True.} or: {^False.}.
}.

Eval on: 'Commands' do: {
  my commands is my commands or: {
    ^Map new
      put: {:args Eval end. ^''.} at: 'q',
      put: {:args Eval modifyFlags: args. ^''.} at: '!f',
      put: {:args ^Reflect strTypeOf: (Eval evaluate: args).} at: 't',
      put: {:args ^(args trim = '') either: {^Eval startEvalServer.} or: {^Eval startEvalServerOnPort: (Eval evaluate: args).}.} at: 'server',
      put: {:args ^'Interpreter metacommands help:
      + q -- Quit
      + t <expression> -- type of expression
      + server [<port>] -- make an eval server on port <port>, or a random port.
      + !server -- kill the eval server
      + !m <expression> -- evaluates and shows the methods of expression.
      + !p <expression> -- evaluates and shows the properties of expression.
      + !f <[no-]flag> -- modifies flag
      + p <expression> -- prints the value of expression
      + h -- show this help'.} at: 'h',
      put: {^Eval stopEvalServer.} at: '!server',
      put: {:args ^Reflect getPropertiesOf: (Eval evaluate: args).} at: '!p',
      put: {:args Pen writeln: (Eval evaluate: args). ^''.} at: 'p',
      put: {:args ^Reflect getMethodsOf: (Eval evaluate: args).} at: '!m'.
  }.
  ^my commands.
}.

Eval on: 'doMeta:' do: {:str:ptr
  var cmd is 'h'.
  var args is ''.
  str trim findPattern: '(\\W?\\w+)(\\s+(.*))?' do: {:parts cmd is parts @ 1. args is parts count > 2 either: {^parts @ 3.} or: ''.}.
  ^(Eval Commands at: cmd) applyTo: args.
}.

Eval on: 'evaluate:' do: { :str
  var eval_result_x is Nil.
  ^(str at: 0, = ':')
    either:
      ({ ^eval_result_x is Eval doMeta: (str skip: 1). } catch: {:e Eval handleException: e.})
    or:
      ({
          ^(str startsWith: 'import') not
            either: ({
                ^Reflect runAtGlobal: {:str ^str eval.} arguments: str.
                } catch: {:e Eval handleException: e. ^Nil.}
            ) or: ({
                ^str eval.
                } catch: {:e Eval handleException: e. ^Nil.}).
        }).
}.
Eval on: 'evaluateFile:' do: { :fl
  {
    Pen yellow write: 'File ', magenta write: fl, yellow write: ' : Interpreting...', brk.
    File new: fl, include.
  } catch: { :e
      Eval handleException: e.
      # get rid of the trash.
      Broom sweep.
  }, run.
}.
Eval on: 'enqueue:' do: { :str
  my evalQueue enqueue: str.
}.
Eval on: 'queueHasItem' do: {
  ^(my evalQueue count !=: 0).
}.
Eval on: 'dequeue' do: { ^my evalQueue dequeue. }.
Eval on: 'pushHist:' do: {:h
  my history push: h.
}.
Eval on: 'executeLast:' do: {:n
  ^me evaluate: (my history @ n).
}.
Eval on: 'getHistory' do: {^my history.}.

Eval on: 'queryState:' do: {:query
    ^(((query countOf: '\'') - (query countOf: '\\\'')) even) & ((query countOf: '{') = (query countOf: '}')) & ((query countOf: '[') = (query countOf: ']')).
}.

Eval init.
Eval setArgs: (Array with: {:i ^Program argument: i. } count: (Program argCount)).
Eval onlyRelevantArgs.

#arguments that were not consumed
var args is Array new.

#global vars for evaler
var _  is Nil.
var __ is Nil.

Eval on: 'tryNumrify:' do: {:s
  var r is s.
  {r is s toNumber.} catch: {r is s.}, run.
  ^r.
}.

# parse arguments
{ ^(Eval argCount > 0). } whileTrue: {
    # get an option
    var opt is Eval shiftArgs.
    args push: opt.
    # when passed -h, show help, then exit.
    opt case: '-h' do: {
        args pop. #consume option.
        Pen green write: 'Citron Evaluator.\n', resetColor.
        var P is Pen.
        P on: 'indent:write:' do: {:i :w Pen write: (((Array < '  ') * i) join: ''). Pen write: w. }.
        P indent: 1 write: 'Eval mode help:', brk.
        P cyan indent: 1 write: 'Eval namespace', resetColor brk.
        P magenta indent: 2 write: '[Eval] setPrompt: [String] ', resetColor write: '-- Sets the prompt.', brk.
        P magenta indent: 2 write: '[Eval] setColor: [String] ', resetColor write: '-- sets the color of the output.', brk.
        P magenta indent: 2 write: '[Eval] getHistory ', resetColor write: '-- returns the 100 last commands.', brk.
        P magenta indent: 2 write: '[Eval] executeLast: [Number] ', resetColor write: '-- evaluates the Nth element of the history list.', brk.
        P magenta indent: 2 write: '[Eval] startEvalServer ', resetColor write: '-- starts an eval server in the background. returns the port.', brk.
        P magenta indent: 2 write: '[Eval] startEvalServerOnPort: [Number] ', resetColor write: '-- same as startEvalServer, with the port specified.', brk.
        P magenta indent: 2 write: '[Eval] end ', resetColor write: '-- Ends the eval.', brk.
        P indent: 1 write: 'Evaluates expressions in a single context.', brk.
        P indent: 1 write: 'Since all expressions are in single lines, pragma oneLineExpressions is active,', brk.
        P indent: 1 write: 'Hence ending expressions with a dot (.) is not required.', brk.
        P indent: 1 write: 'All the args that were not consumed are in the variable `args`.', brk.
        P cyan indent: 1 write: 'Program arguments\n',
          resetColor indent: 2 write: '-p : set the prompt\n',
          indent: 2 write: '-c : set the result color\n',
          indent: 2 write: '-h : show this help\n',
          indent: 2 write: '-f : evaluate file. many can be passed, evals in passed order\n',
          indent: 2 write: '-F<[no-]flag> : enables the passed flag\n',
          indent: 2 write: '-Fs : display all the available flags\n',
          indent: 2 write: '-e : evaluate expression and exit, all args after the expr will be passed to the code as var `args`\n',
          indent: 2 write: '-v : print version information and exit\n',
          magenta indent: 1 write: 'Any other option will be consumed and dumped into the `args` array.', brk.
        P resetColor.
        Program exit.
    # when passed -p, get the next arg, and set the prompt to that.
    }, case: '-p' do: {
        args pop. #consume option..
        var value is Eval shiftArgs.
        (value isNil) ifTrue: { thisBlock error: '-p requires an arg.'. }.
        Eval setPrompt: value.
    # when passed -pc, get the next arg, and set the continuation prompt to that.
    }, case: '-pc' do: {
        args pop. #consume option..
        var value is Eval shiftArgs.
        (value isNil) ifTrue: { thisBlock error: '-pc requires an arg.'. }.
        Eval setContinuation: value.
    # when passed -c, get the next arg, and set the result color to that.
    }, case: '-c' do: {
        args pop. #consume option.
        var value is Eval shiftArgs.
        (value isNil) ifTrue: { thisBlock error: '-c requires an arg, valid arguments are: \n\t' + (((Eval allowedColors) split: '|') join: '\n\t'). }.
        Eval setColor: value.
    }, case: '-f' do: {
        args pop. #consume option.
        var file is Eval shiftArgs.
        (file isNil) ifTrue: { thisBlock error: '-f requires a file name.'. }.
        Eval enqueue: file.
    }, case: '-Fs' do: {
        args pop. #consume option.
        Pen writeln: (Eval flags keys join: ', ').
        Program exit.
    }, case: '-e' do: {
        args pop. #consume option..
        var value is Eval shiftArgs.
        (value isNil) ifTrue: { thisBlock error: '-e requires an argument.'. }.
        { ^(Eval argCount > 0). } whileTrue: { args push: Eval shiftArgs. }. #consume all other arguments.
        # if it ends in a dot, delete it.
        args imap: {:i:n Reflect addGlobalVariable: '$' + (i + 1). Reflect set: '$' + (i + 1) to: (Eval tryNumrify: n).}.
        value findPattern: '(.*)\\.' do: {:p value is p at: 1.}.
        Pen write: (Eval evaluate: value).
        Program exit.
    }, case: '-v' do: {
        Pen writeln: 'Citron Version ' + Reflect version.
        Pen writeln: 'Built with the extension prefix of ' + File extensionsPath.
        Pen writeln: 'Compiled with ' + Reflect compilerInfo.
        Program exit.
    }, case: '-V' do: {
        Pen writeln: 'Citron'.
        Pen writeln: '[%L]' % [(Reflect version split: '.')].
        Program exit.
    }, default: {
      opt startsWith: '-F', ifTrue: {
        args pop. #consume option.
        var flag is opt skip: 2.
        (flag = '') ifTrue: { thisBlock error: '-F requires a flag name.\nSee -Fs'. }.
        Eval modifyFlags: flag.
      }.
    }, switch. # do not consume any other option.
}.
Pen green write: ?>Project Citron : The Programming Language (V<?, write:(Reflect version) + ')', resetColor brk
write: ?>Eval Mode, parameters related to eval are in the Eval namespace.
run with '-h' to read the eval mode help.
<?.

Eval on: 'flatten:' do: {:list
  var lst is Array new.
  list each_v: {:l
    (Reflect isObject: l linkedTo: Array) either: {
      lst is lst + (Eval flatten: l).
    } or: {
      lst push: l.
    }.
  }.
  ^lst.
}.

Eval on: 'allTheNames' do: {
  ^(Eval Commands keys fmap: {:i ^':' + i.}) + ['var', 'my', 'is'] + (Eval flatten: Reflect getContext).
}.

Eval on: 'allTheNames:' do: {:obj
  ^obj isNil not either: {^[(False), (Reflect getMethodsOf: obj)].} or: {^[(True), (Eval allTheNames)].}.
}.

# Eval on: 'redraw:at:' do: {:inp:cursor
#   var cols is Program env: 'COLUMNS', or: '89', toNumber.
#   var remainingCols is cols - (inp length) max: 0.
#   remainingCols < 2 ifTrue: {
#     Pen write: ('\b' * cursor) + '<' + (inp is inp from: (inp length - cols) length: cols - 1) + ('\b' * (inp length - 1)).
#   }, else: {
#     Pen write: ('\b' * cursor) + inp + ('\b' * (inp length - cursor - 1)).
#   }.
# }.
Eval on: 'redraw:at:' do: {:inp:cursor
  var ctn is Eval prompt.
  ctn is inp length > (TerminalWidth - (ctn length)) either: '<' or: ctn.
  Pen clearLine.
  inp length > 1 ifTrue: {
    var diff is 0.
    var iinp is (cursor > (var first_visible is (inp length - TerminalWidth - (ctn length) max: 0))) either: { ^inp skip: first_visible - 2. } or: { var tdiff is TerminalWidth - (ctn length). var f is inp skip: cursor - 1. diff is f length - tdiff. ^f from: 0 length: tdiff. }.
    (Eval getFlag: 'highlight') ifTrue: {iinp is Highlight highlight: iinp.}.
    Pen cyan write: ctn, resetColor.
    # Pen for: (File special: 'stderr'), writeln: [first_visible, cursor].
    Pen write: '%s%s' % [iinp, ('\b' * (inp length - cursor - diff - 1 max: 0, min: inp length))].
  }, else: {
    Pen cyan write: ctn, resetColor write: inp.
  }.
}.

Eval on: 'repl' do: {
  {^True.} whileTrue: {
    var hindex is Eval getHistory count.
    var ncmessage is ' <- No completion'.
    var stdin is File special: 'stdin'.
    inp is ''.
    # break the repl when `end` is True.
    Eval break break.
    (Eval queueHasItem) ifTrue: {
      var item is Eval dequeue.
      Eval evaluateFile: item.
    }.
    Eval queueHasItem continue.
    Pen cyan write: (Eval prompt), resetColor.

    var inc is stdin readBytes: 1.
    var last_was_comp is False.
    var last_comp_entry is ''.
    var last_comp_index is -1.
    var last_comp_rewind is 0.
    var last_toc is 'Object'.
    var done is False.
    var cursor is 0.
    var multichar_in is Array new.
    {^done.} whileFalse: {
      inc = '\t' ifTrue: {#<Tab>
          var candidate is 'Nil'.
          var toc is (inp trim or: '  ') split: ' ', last.
          last_was_comp ifTrue: {
            var toremove is ((toc length) - (last_comp_entry length)).
            Pen write: '\b \b' * toremove.
            inp is inp removeFrom: (cursor - toremove) to: cursor.
            cursor is (cursor - toremove) max: 0.
          }.
          toc is last_was_comp either: last_comp_entry or: toc.
          last_comp_entry is toc.
          var flipper is OneGateFlipper new.
          last_toc is (inp trim or: 'Nil') split: ' ', filter: {:_:v (v endsWith: ':') ifTrue: {flipper set. ^False.}. ^((v endsWith: ':') | (flipper get)) not. }.
          last_toc is (last_toc count) >=: 2, either: {^last_toc init last.} or: 'Nil'.
          var candidates is Eval allTheNames: ({^Reflect getObject: (['my', 'var'] contains: last_toc, either: Nil or: last_toc).} catch: {^Nil.}, run).
          var skipthis is candidates @ 0.
          candidates is (candidates @ 1) filter: {:_:i ^i startsWith: toc.}.
          candidates count !=: 0, ifTrue: {
            candidate is candidates @ (last_comp_index is (last_comp_index +=: 1) >=: (candidates count), either: 0 or: last_comp_index).
            var cc is candidate skip: toc length.
            Pen cyan write: cc, resetColor.
            Pen yellow write: (var iis is ' [from %s]' % [last_toc]), resetColor.
            last_comp_rewind is iis length.
            inp is inp insert: cc at: cursor.
            cursor +=: cc length.
          }, else: {
            Pen yellow write: ncmessage + '\a', resetColor.
            last_comp_rewind is (ncmessage length).
          }.
          last_was_comp is True.
          skipthis ifTrue: {last_toc is candidate.}.
        }, else: {
          inc case: '\xd' do: {#<Enter>
            # Pen brk.
            # (cursor !=: inp length) ifTrue: {
            #   Pen write: (inp from: cursor length: (inp length - cursor)).
            # }.
            var original_inp is inp.
            inp is inp trim.
            inp length > 0 ifTrue: {
              (inp at: 0, = ':') ifTrue: {done is True.}, else: {
                (inp at: (inp length - 1), !=: '.') ifTrue: {
                  inp is inp + '.'.
                }.
                # Pen yellow writeln: '  [PARSING "%s"]' % [inp], resetColor.
                # done is (([(inp countOf: '{'), (inp countOf: '['), (inp countOf: '(')] = [(inp countOf: '}'), (inp countOf: ']'), (inp countOf: ')')]) & (((inp countOf: '\'') - (inp countOf: '\\\'')) mod: 2, = 0)).
                # Pen yellow writeln: '[PARSED "%s":%d]' % [pfinal, (pfinal instrCount)], resetColor.
                # done ifTrue: {
                # var pfinal is AST parse: inp.
                # done is (pfinal count !=: 0).
                done is True.
                # }.
                inp is original_inp.
              }.
            }, else: { Pen brk. done is True. }.
          }, case: '\x3' do: {#<^C>
            inp is ''.
            cursor is 0.
            Pen red writeln: 'Interrupted', resetColor.
            done is True.
          }, case: '\x8' do: {#<\b>
            cursor > 0 ifTrue: {
              inp is inp removeFrom: (cursor - 1) to: cursor.
              cursor -=: 1.
              Pen write: '\x8 \x8'.
            }, else: { Pen write: '\a'. }.
          }, case: '\x11' do: {
            var toc is (inp trim or: '  ') split: ' ', last.
            var recs is '%:L' % [' ', (Eval allTheNames filter: {:_:n ^n startsWith: toc.})].
            Pen cyan write: recs, resetColor.
          }, case: '\x1b' do: {
            inc is stdin readBytes: 2.
            inc case: '\x5b\x41' do: { #Up Arrow
              hindex > 0 ifTrue: {
                cursor is (inp is Eval getHistory at: (hindex is hindex - 1)) length.
              }.
            }, case: '\x5b\x42' do: { #Down Arrow
              (hindex > 0) & (Eval getHistory count > 0) ifTrue: {
                hindex +=: 1.
                Pen write: '\b' * (inp length).
                inp is Eval getHistory.
                inp count <=: hindex, ifTrue: {hindex is inp count.}.
                inp is inp at: hindex - 1.
                cursor is inp length.
              }, else: {
                hindex is 0.
                Pen write: '\b \b' * (inp length).
                inp is ''.
                cursor is 0.
              }.
            }, case: '\x5b\x43' do: { #Right Arrow
              (cursor < inp length) ifTrue: {
                cursor +=: 1.
              }, else: {Pen write: '\a'.}.
            }, case: '\x5b\x44' do: { #Left Arrow
              (cursor > 0) ifTrue: {
                cursor -=: 1.
              }, else: {Pen write: '\a'.}.
            }, case: '\x5b\x31' do: { #Supposedly <ctrl>
              Pen write: '\a' * 23.
              inc is stdin readBytes: 3.
              (cursor > 0) ifTrue: {
                (inc = '\x3b\x35\x44') ifTrue: { #^Left Arrow
                  var ct is inp from: 0 to: cursor.
                  var ct is ct trim.
                  ct is (ct lastIndexOf: ' ').
                  cursor is ct + 1.
                }, else: {
                  (inc = '\x3b\x35\x43') ifTrue: { #^Right Arrow
                    var ct is (var ix is inp from: cursor to: (inp length), trim) indexOf: ' ', - 1.
                    cursor is cursor + ct + ((inp length) - (ix length)).
                  }.#, else: { Pen red write: inc. }.
                }.
              }.
            }, default: {
              Pen write: inc toByteArray.
            }, switch.
          }, default: {
            inp is inp insert: inc at: cursor.
            Eval redraw: inp at: cursor.
            cursor +=: 1.
          }, switch.
          last_was_comp is False.
        }.
      Eval redraw: inp at: cursor - 1.
      done break.
      inc is stdin readBytes: 1.
    }.
    hindex is Eval getHistory count.
    # Pen cyan write: ' [cursor %d in (%s)]' % [cursor, (inp)], resetColor.
    (inp trim = '') continue.
    Pen brk.
    # {^Eval queryState: inp.} whileFalse: {
    #  inp append: (inp countOf: '\'', even either: '\n' or: '') + ({
    #    Pen cyan write: Eval continuation * (1 + (inp countOf: '{') - (inp countOf: '}')), resetColor.
    #    ^Program waitForInput.
    #    } run).
    #  }.
    # if it ends in a dot, get rid of it.
    inp is inp trim.
    (inp at: (inp length - 1), = '.') ifTrue: {
      inp is inp from: 0 length: (inp length - 1).
    }.

    # Syntactic errors will not be passed to the eval. # TODO: handle that.
    var ret is Eval evaluate: inp.
    Eval getFlag: 'printvs', ifTrue: { 'Pen %s write: ret toString' formatObjects: [(Eval color)], eval. }.
    Pen resetColor.
    __ is _.
    _ is ret.
    Eval pushHist: inp.
    #Broom sweep. #Keep the darn pointers in memory
    ret toString length > 0 ifTrue: { Pen brk. }.
  }.
}.

Eval repl.
