#!/usr/bin/env ctr
#
contextPurity is False. #This is not a pure context, since objects are mutated in-between evaluations. so disallowing purely functional things.
#Pen write: 'Extensions: ' + (File extensionsPath), brk.
File new: (File extensionsPath) + '/extensions/fileutils.ctr', include.

ImportLib Queue.
ImportLib LRArray.

Eval is Object new.
Eval on: 'init' do: {
  my end is False.
  my color is 'resetColor'.
  my prompt is '>>> '.
  my args is Array new.
  my allowedColors is ('red blue magenta cyan yellow green resetColor' split: ' ') join: '|'.
  my evalQueue is Queue new.
  my globalvars is False.
  my history is LRArray new init: 100.
  my commands is Nil.
  me genReader: 'eServer'.
  ^me.
}.
Eval on: 'end' do: { my end is True. me joinEvalServer. }.
Eval on: 'break' do: { my end ifTrue: {Broom sweep.}. my end break. }.
Eval on: 'allowedColors' do: { ^my allowedColors. }.
Eval on: 'isAllowedColor:' do: { :c
  ^(c containsPattern: my allowedColors).
}.
Eval on: 'setColor:' do: { :c
  (me isAllowedColor: c) ifFalse: { thisBlock error: 'value $$c' + ' is not an allowed color.'. }.
  my color is c.
}.
Eval on: 'setPrompt:' do: { :p my prompt is p. }.
Eval on: 'setArgs:' do: { :a my args := a. }.
Eval on: 'color' do: { ^my color. }.
Eval on: 'prompt' do: { ^my prompt. }.
Eval on: 'shiftArgs' do: { ^(my args shift). }.
Eval on: 'argCount' do: { ^(my args count). }.
Eval on: 'onlyRelevantArgs' do: { my args do shift shift done. }. #get rid of ./ctr eval

Eval on: 'startEvalServer' do: {
  var port is 5000 + (Dice rollWithSides: 1000).

  var EvalServer is Object new.
  EvalServer on: 'evaluate:' do: {:str
      ^str eval.
  }.

  my eServer is Program new: {:p
      p port: port.
      p serve: EvalServer.
  }.

  ^port.
}.

Eval on: 'startEvalServerOnPort:' do: {:port

  var EvalServer is Object new.
  EvalServer on: 'evaluate:' do: {:str
      ^str eval.
  }.

  my eServer is Program new: {:p
      p port: port.
      p serve: EvalServer.
  }.

  ^port.
}.

Eval on: 'joinEvalServer' do: {
  my eServer ifFalse: {^False.}.
  my eServer join.
}.

Eval on: 'Commands' do: {
  my commands is my commands or: {
    ^Map new
      put: {:args Eval end.} at: 'q',
      put: {:args ^Reflect strTypeOf: (args eval).} at: 't'.
  }.
  ^my commands.
}.

Eval on: 'doMeta:' do: {:str
  ^(Eval Commands at: (str at: 0)) applyTo: (str skip: 1, trim).
}.

Eval on: 'evaluate:' do: { :str
  var x is Nil.
  (str at: 0, = ':')
    either:
      ({ ^x is Eval doMeta: (str skip: 1). } catch: {:e Pen red write: 'Uncaught exception occurred: ', brk. x is e.})
    or:
      ({ ^x is str eval toString. } catch: {:e Pen red write: 'Uncaught exception occurred: ', brk. x is e.}).
    Pen resetColor.
  ^(x containsPattern: '\\[\\w+\\]') either: '' or: x.
}.
Eval on: 'evaluateFile:' do: { :fl
  { File new: fl, include. } catch: { :e
    # try to recover from some small errors.
      Pen red write: e, brk.
      # get rid of the trash.
      Broom sweep.
  }, run.
}.
Eval on: 'enqueue:' do: { :str
  my evalQueue enqueue: str.
}.
Eval on: 'queueHasItem' do: {
  ^(my evalQueue count !=: 0).
}.
Eval on: 'dequeue' do: { ^my evalQueue dequeue. }.
Eval on: 'setGlobalVars:' do: { :t my globalvars is t. }.
Eval on: 'globalvars' do: {^my globalvars. }.
Eval on: 'handleGlobalVars:' do: { :inp
  var repl is inp.
  (my globalvars) ifTrue: {
    inp findPattern: '^\\s*\\bvar\\s+\\b(.*)\\b'
                 do: { :name var n is name at: 1. Reflect addGlobalVariable: n. }.
    }.
    #Pen write: repl, brk.
    ^inp.
}.
Eval on: 'pushHist:' do: {:h
  my history push: h.
}.
Eval on: 'executeLast:' do: {:n
  ^me evaluate: (my history @ n).
}.
Eval on: 'getHistory' do: {^my history.}.

Eval init.
Eval setArgs: (Array with: {:i ^Program argument: i. } count: (Program argCount)).
Eval onlyRelevantArgs.

#arguments that were not consumed
var args is Array new.

#global vars for evaler
var ra is Nil.
var rb is Nil.
var rc is Nil.
var rd is Nil.
var re is Nil.
var rf is Nil.


# parse arguments
{ ^(Eval argCount > 0). } whileTrue: {
    # get an option
    var opt is Eval shiftArgs.
    args push: opt.
    # when passed -h, show help, then exit.
    opt singleCase: '-h' do: {
        args pop. #consume option.
        Pen green write: 'Citron Evaluator.\n', resetColor.
        var P is Pen new.
        P on: 'indent:write:' do: {:i :w Pen write: (((Array < '  ') * i) join: ''). Pen write: w. }.
        P indent: 1 write: 'Eval mode help:', brk.
        P cyan indent: 1 write: 'Eval namespace', resetColor brk.
        P magenta indent: 2 write: '[Eval] setPrompt: [String] ', resetColor write: '-- Sets the prompt.', brk.
        P magenta indent: 2 write: '[Eval] setColor: [String] ', resetColor write: '-- sets the color of the output.', brk.
        P magenta indent: 2 write: '[Eval] getHistory ', resetColor write: '-- returns the 100 last commands.', brk.
        P magenta indent: 2 write: '[Eval] executeLast: [Number] ', resetColor write: '-- evaluates the Nth element of the history list.', brk.
        P magenta indent: 2 write: '[Eval] startEvalServer ', resetColor write: '-- starts an eval server in the background. returns the port.', brk.
        P magenta indent: 2 write: '[Eval] startEvalServerOnPort: [Number] ', resetColor write: '-- same as startEvalServer, with the port specified.', brk.
        P magenta indent: 2 write: '[Eval] end ', resetColor write: '-- Ends the eval.', brk.
        P indent: 1 write: 'Evaluates expressions in a single context.', brk.
        P indent: 1 write: 'Since all expressions are in single lines, pragma oneLineExpressions is active,', brk.
        P indent: 1 write: 'Hence ending expressions with a dot (.) is not required.', brk.
        P indent: 1 write: 'All the args that were not consumed are in the variable `args`.', brk.
        P cyan indent: 1 write: 'Program arguments\n',
          resetColor indent: 2 write: '-p : set the prompt\n',
          indent: 2 write: '-c : set the result color\n',
          indent: 2 write: '-h : show this help\n',
          indent: 2 write: '-f : evaluate file. many can be passed, evals in passed order\n',
          indent: 2 write: '-e : evaluate expression and exit, all args after the expr will be passed to the code as var `args`\n',
          indent: 2 write: '--global-vars : variables in a single line are global, but this leaks a minute amount of memory.\n',
          magenta indent: 1 write: 'Any other option will be consumed and dumped into the `args` array.', brk.
        P red write: 'new Global variables can be created using Reflection.', brk.
        P resetColor.
        Program exit.
    # when passed -p, get the next arg, and set the prompt to that.
    }, singleCase: '-p' do: {
        args pop. #consume option..
        var value is Eval shiftArgs.
        (value isNil) ifTrue: { thisBlock error: '-p requires an arg.'. }.
        Eval setPrompt: value.
    # when passed -c, get the next arg, and set the result color to that.
    }, singleCase: '-c' do: {
        args pop. #consume option.
        var value is Eval shiftArgs.
        (value isNil) ifTrue: { thisBlock error: '-c requires an arg, valid arguments are: \n\t' + (((Eval allowedColors) split: '|') join: '\n\t'). }.
        Eval setColor: value.
    }, singleCase: '-f' do: {
        args pop. #consume option.
        var file is Eval shiftArgs.
        (file isNil) ifTrue: { thisBlock error: '-f requires a file name.'. }.
        Eval enqueue: file.
    }, singleCase: '-e' do: {
        args pop. #consume option..
        var value is Eval shiftArgs.
        (value isNil) ifTrue: { thisBlock error: '-e requires an argument.'. }.
        { ^(Eval argCount > 0). } whileTrue: { args push: Eval shiftArgs. }. #consume all other arguments.
        # if it ends in a dot, delete it.
        value findPattern: '(.*)\\.' do: {:p value is p at: 1.}.
        value is Eval handleGlobalVars: value.
        Pen write: (Eval evaluate: value).
        Program exit.
    }, singleCase: '--global-vars' do: {
        args pop. #consume option.
        Eval setGlobalVars: True.
    }. # do not consume any other option.
}.
Pen green. ?>Project Citron : The Programming Language (V<?. Pen write:(Reflect version) + ')' ,resetColor brk.
?>Eval Mode, parameters related to eval are in the Eval namespace.
run with '-h' to read the eval mode help.
<?.
(Eval globalvars) do ifFalse: {
    Pen write: 'local variables will not be reflected upon,\nso to get new global variables, use '. Pen green.
    Pen write: 'Reflect addGlobalVariable: \'name\'', brk.
} done.

{ ^False. } whileFalse: {
  # break the repl when `end` is True.
    Eval break.
    (Eval queueHasItem) ifTrue: {
      var item is Eval dequeue.
      Eval evaluateFile: item.
    }.
    Eval queueHasItem continue.
    Pen cyan write: (Eval prompt), resetColor.

    # get input, get rid of the trailing \n. If empty, don't bother evaluating.
    var inp is (Program waitForInput) trim.
    (inp = '') continue.

    # if it ends in a dot, get rid of it.
    inp findPattern: '(.*)\\.' do: {:p inp is p at: 1.}.

    inp is Eval handleGlobalVars: inp.

    # Syntactic errors will not be passed to the eval. # TODO: handle that.
    #Pen write: inp, brk.
    Pen write: (var ret is Eval evaluate: inp).
    Eval pushHist: inp.
    #Broom sweep. #Keep the darn pointers in memory
    ret length > 0 ifTrue: { Pen brk. }.
}.
