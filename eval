#!/usr/bin/env ctr
#
contextPurity is False. #This is not a pure context, since objects are mutated in-between evaluations. so disallowing purely functional things.
#Pen write: 'Extensions: ' + (File extensionsPath), brk.
File new: (File extensionsPath) + '/extensions/fileutils.ctr', include.

ImportLib Queue.
ImportLib LRArray.

# Preprocessor is Object cnew: {my code is ''. my buffer is ''. my result is ''.}.
# Preprocessor on: 'load:' do: {:str my code is str.}.
# Preprocessor on: 'emit:' do: {:str my result append: str.}.
# Preprocessor on: 'emitbuf:' do: {:str my buffer append: str.}.
# Preprocessor on: 'process' do: {
#   var chars is my code characters.
#   var in_directive is False.
#   var self is me.
#   chars each: {:i:char
#     ((i < ((chars count) - 1)) & (char = '%') & ((chars @ (i + 1)) = '}')) do ifTrue: {in_directive is False. self beginproc.}, continue done.
#     ((i < ((chars count) - 1)) & (char = '%') & ((chars @ (i + 1)) = '{')) do ifTrue: {in_directive is True.}, continue done.
#     in_directive do ifTrue: {self emitbuf: char.}, continue done.
#     self emit: char.
#   }.
#   ^result.
# }.
# Preprocessor on: 'beginproc' do: {
#   my buffer is (my buffer from: 2 to: (my buffer length)) trim.
#   Pen write: (my buffer), brk.
#   var self is me.
#   # var ? is Pen.
#   # Pen is Pen new.
#   # Pen on: 'write:' do: {:s self emit: s.}.
#   # Pen on: 'brk' do: {self emit: '\n'.}.
#   # Pen on: 'respondTo:' do: {:s}.
#   # Pen learn: 'respondTo:and:' means: 'respondTo:'.
#   # Pen learn: 'respondTo:and:and:' means: 'respondTo:'.
#   # -> {Code $$scope_var}
#   me handleDirectives.
#   #my buffer eval.
#   Pen write: my buffer, brk.
#   # Pen is ?.
#   Broom sweep.
#   my buffer is ''.
# }.
# Preprocessor on: 'handleDirectives' do: {
#   var buf is ''.
#   var to_exec is ''.
#   var in_inject is False.
#   var o_bl is 0.
#   var skip is 0.
#   my buffer characters each: {:i:char:chars
#     Pen green write: ('skip:$$skip char:$$char obl:$$o_bl inject:$$in_inject'), resetColor brk.
#     (skip > 0) do ifTrue: {skip -=: 1.}, continue done.
#     ((i < ((chars count) - 2)) & (char = '-') & ((chars @ (i + 1)) = '>') & ((chars @ (i + 2)) = '{')) do ifTrue: {in_inject is True. o_bl +=: 1. skip is 2.}, continue done.
#     (char = '{') ifTrue: {o_bl +=: 1.}.
#     (char = '}') ifTrue: {o_bl -=: 1.}.
#     (o_bl = 0) ifTrue: {in_inject is False. 'buf is Preprocessor transform: buf.'. to_exec append: buf. buf is ''.}.
#     in_inject do ifTrue: {buf append: char.}, continue done.
#     to_exec append: char.
#   }.
#   my buffer is to_exec.
# }.
# Preprocessor on: 'transform:' do: {:blk Pen red write: blk, resetColor brk.
#   ^blk.
# }.
Eval is Object new.
Eval on: 'init' do: {
  my end is False.
  my color is 'resetColor'.
  my prompt is '>>> '.
  my args is Array new.
  my allowedColors is ('red blue magenta cyan yellow green resetColor' split: ' ') join: '|'.
  my evalQueue is Queue new.
  my globalvars is False.
  my history is LRArray new init: 100.
  ^me.
}.
Eval on: 'end' do: { my end is True. }.
Eval on: 'break' do: { my end ifTrue: {Broom sweep.}. my end break. }.
Eval on: 'allowedColors' do: { ^my allowedColors. }.
Eval on: 'isAllowedColor:' do: { :c
  ^(c containsPattern: my allowedColors).
}.
Eval on: 'setColor:' do: { :c
  (me isAllowedColor: c) ifFalse: { thisBlock error: 'value $$c' + ' is not an allowed color.'. }.
  my color is c.
}.
Eval on: 'setPrompt:' do: { :p my prompt is p. }.
Eval on: 'setArgs:' do: { :a my args := a. }.
Eval on: 'color' do: { ^my color. }.
Eval on: 'prompt' do: { ^my prompt. }.
Eval on: 'shiftArgs' do: { ^(my args shift). }.
Eval on: 'argCount' do: { ^(my args count). }.
Eval on: 'onlyRelevantArgs' do: { my args do shift shift done. }. #get rid of ./ctr eval
Eval on: 'evaluate:' do: { :str
  { str execute. } catch: { :e
    # try to recover from some small errors.
      Pen red write: e, brk.
      thisBlock error: e.
      # get rid of the trash.
      Broom sweep.
  }, run.
}.
Eval on: 'evaluateFile:' do: { :fl
  { File new: fl, include. } catch: { :e
    # try to recover from some small errors.
      Pen red write: e, brk.
      # get rid of the trash.
      Broom sweep.
  }, run.
}.
Eval on: 'enqueue:' do: { :str
  my evalQueue enqueue: str.
}.
Eval on: 'queueHasItem' do: {
  ^(my evalQueue count !=: 0).
}.
Eval on: 'dequeue' do: { ^my evalQueue dequeue. }.
Eval on: 'setGlobalVars:' do: { :t my globalvars is t. }.
Eval on: 'globalvars' do: {^my globalvars. }.
Eval on: 'handleGlobalVars:' do: { :inp
  var repl is inp.
  (my globalvars) ifTrue: {
    repl is inp findPattern: '^\\s*var\\s+\\b(.*)\\b\\s+(is|:=)\\s+(.*?)\\.'
               do: { :name var n is '\'' + (name @ 1) + '\''. var r is (name @ 3). var s is 'Reflect addGlobalVariable: $$n'+'.\nReflect set: $$n to: $$r'+'.'. ^s.}.
    }.
    #Pen write: repl, brk.
    ^repl.
}.
Eval on: 'pushHist:' do: {:h
  my history push: h.
}.
Eval on: 'executeLast:' do: {:n
  ^me evaluate: (my history @ n).
}.
Eval on: 'getHistory' do: {^my history.}.

Eval init.
Eval setArgs: (Array with: {:i ^Program argument: i. } count: (Program argCount)).
Eval onlyRelevantArgs.

#arguments that were not consumed
var args is Array new.

#global vars for evaler
var ra is Nil.
var rb is Nil.
var rc is Nil.
var rd is Nil.
var re is Nil.
var rf is Nil.


# parse arguments
{ ^(Eval argCount > 0). } whileTrue: {
    # get an option
    var opt is Eval shiftArgs.
    args push: opt.
    # when passed -h, show help, then exit.
    opt singleCase: '-h' do: {
        args pop. #consume option.
        Pen green write: 'Citron Evaluator.\n', resetColor.
        var P is Pen new.
        P on: 'indent:write:' do: {:i :w Pen write: (((Array < '\t') * i) join: ''). Pen write: w. }.
        P indent: 1 write: 'Eval mode help:', brk.
        P cyan indent: 1 write: 'Eval namespace', resetColor brk.
        P magenta indent: 2 write: '[Eval] setPrompt: [String] ', resetColor write: '-- Sets the prompt.', brk.
        P magenta indent: 2 write: '[Eval] setColor: [String] ', resetColor write: '-- sets the color of the output.', brk.
        P magenta indent: 2 write: '[Eval] getHistory ', resetColor write: '-- returns the 100 last commands.', brk.
        P magenta indent: 2 write: '[Eval] executeLast: [Number] ', resetColor write: '-- evaluates the Nth element of the history list.', brk.
        P magenta indent: 2 write: '[Eval] end ', resetColor write: '-- Ends the eval.', brk.
        P indent: 1 write: 'Evaluates expressions in a single context.', brk.
        P indent: 1 write: 'Since all expressions are in single lines, pragma oneLineExpressions is active,', brk.
        P indent: 1 write: 'Hence ending expressions with a dot (.) is not required.', brk.
        P indent: 1 write: 'All the args that were not consumed are in the variable `args`.', brk.
        P cyan indent: 1 write: 'Program arguments\n',
          resetColor indent: 2 write: '-p : set the prompt\n',
          indent: 2 write: '-c : set the result color\n',
          indent: 2 write: '-h : show this help\n',
          indent: 2 write: '-f : evaluate file. many can be passed, evals in passed order\n',
          indent: 2 write: '-e : evaluate expression and exit, all args after the expr will be passed to the code as var `args`\n',
          indent: 2 write: '--global-vars : variables in a single line are global, but this leaks a minute amount of memory.\n',
          magenta indent: 1 write: 'Any other option will be consumed and dumped into the `args` array.', brk.
        P red write: 'new Global variables can be created using Reflection.', brk.
        P resetColor.
        Program exit.
    # when passed -p, get the next arg, and set the prompt to that.
    }, singleCase: '-p' do: {
        args pop. #consume option..
        var value is Eval shiftArgs.
        (value isNil) ifTrue: { thisBlock error: '-p requires an arg.'. }.
        Eval setPrompt: value.
    # when passed -c, get the next arg, and set the result color to that.
    }, singleCase: '-c' do: {
        args pop. #consume option.
        var value is Eval shiftArgs.
        (value isNil) ifTrue: { thisBlock error: '-c requires an arg, valid arguments are: \n\t' + (((Eval allowedColors) split: '|') join: '\n\t'). }.
        Eval setColor: value.
    }, singleCase: '-f' do: {
        args pop. #consume option.
        var file is Eval shiftArgs.
        (file isNil) ifTrue: { thisBlock error: '-f requires a file name.'. }.
        Eval enqueue: file.
    }, singleCase: '-e' do: {
        args pop. #consume option..
        var value is Eval shiftArgs.
        (value isNil) ifTrue: { thisBlock error: '-e requires an argument.'. }.
        { ^(Eval argCount > 0). } whileTrue: { args push: Eval shiftArgs. }. #consume all other arguments.
        # if it doesn`t end in a dot, add it.
        ((value at: (value length - 1)) !=: '.') ifTrue: {
            value append: '.'.
        }.
        value is Eval handleGlobalVars: value.
        Eval evaluate: value.
        Program exit.
    }, singleCase: '--global-vars' do: {
        args pop. #consume option.
        Eval setGlobalVars: True.
    }. # do not consume any other option.
}.
Pen green. ?>Project Citron : The Programming Language (V<?. Pen write:(Reflect version) + ')' ,resetColor brk.
?>Eval Mode, parameters related to eval are in the Eval namespace.
run with '-h' to read the eval mode help.
local variables will not be reflected upon,
so to get new global variables, use <?. Pen green.
(Eval globalvars) do ifFalse: {
    Pen write: 'Reflect addGlobalVariable: \'name\'', brk.
}, ifTrue: {Pen write: 'var name is value', brk.} done. Pen resetColor.

{ ^False. } whileFalse: {
  # break the repl when `end` is True.
    Eval break.
    (Eval queueHasItem) ifTrue: {
      var item is Eval dequeue.
      Eval evaluateFile: item.
    }.
    Eval queueHasItem continue.
    Pen cyan write: (Eval prompt), resetColor.

    # get input, get rid of the trailing \n. If empty, don't bother evaluating.
    var inp is (Program waitForInput) trim.
    (inp = '') continue.

    # if it doesn`t end in a dot, add it.
    ((inp at: (inp length - 1)) !=: '.') ifTrue: {
        inp append: '.'.
    }.
    inp is Eval handleGlobalVars: inp.

    # Syntactic errors will not be passed to the eval. # TODO: handle that.
    var eval_color is Eval color.
    inp is 'Pen $$eval_color' + '.\n' + inp + '\nPen resetColor.'.
    #Pen write: inp, brk.
    Eval evaluate: inp.
    Eval pushHist: inp.
    #Broom sweep. #Keep the darn pointers in memory
    Pen brk.
}.
