.TH "Citron v0.0.7.4-boehm-gc" 1 "30 March 2018" "The Citron programming language Manual"
.SH NAME
ctr \- run a Citron program
.PP
citron \- interface to citron eval
.SH SYNOPSIS
ctr [PROGRAM]
.PP
citron [arguments]
.SH DESCRIPTION
Citron is a general purpose programming language for UNIX\-like operating systems.
.SH REFERENCE MANUAL
Citron has 5 literals:
.RS 4
.br
- Nil
.br
- Booleans (True, False)
.br
- Numbers (1, -2, 3.5)
.br
- Strings 'All Strings are UTF8!'
.br
- Code Blocks { parameters code }
.br

.SH BASIC INSTRUCTIONS
.SH ASSIGNMENT
.RE
Assignment in Citron has a few forms, a simple binding (variable is expression) or (variable := expression)
a strictly private binding (variable => expression) [Which can be used in constructor messages]
and a decomposition binding whose explanation follows:


Every object that implements the 'unpack:' method, hereon called 'decomposable' and 'algebraic',
is mostly a wrapper around smaller parts, for instance, an array is a container that only conatins some Objects.
It does not change the objects, nor does it have any other property that can cause us to be unable to recreate those objects
given said array. hence, we can deconstruct the array into its creating objects.


Consider an object. an object can be called a mapping from its property names as keys, to their values as, well, values.
much like a Map. However, since the object`s methods require a reference to it, they cannot be safely deconstructed.


this concept (algebraic decomposition) is done by creating a wireframe of sorts, and telling the object to deconstruct itself
based off that wireframe.
E.g.

.pp
.nf
.rs
var \fBtestMap\fR is Map cnew: {
		\fBtest\fR => [1,2,3,4,5].
		\fBkey1\fR => Map new put: \fBme\fR at: 'test'.
}.
.re
.rs
(Map cnew: {
		\fI#Take the third element from the right, and bind it to 'a'
		\fBtest\fR => ['*_', 'a', '_', '_'].
		\fI#Take the value at 'key1',
		#take its' value at 'test',
		#take its' value at 'test' and bind it to 'b'.\fR
		\fBkey1\fR => Map cnew: {\fBtest\fR => (Map cnew: {\fBtest\fR => 'b'.}).}
}) is \fBtestMap\fR.
.fi
.RE
.pp

Returning algebraic object types from functions, is often used to return several values from said function.
:: TODO : Finish this section.
.SH CORE MESSAGES
The following messages are part of the Core API of the Citron Programming Language:
.br
.PP
.SS

.SH
 Nil
.B _OBJ_DEF Nil
.BR

.PP
.SS
.B Nil represents 'nothing' or NULL in other languages.
 Any object property that has not been assigned a value
 will contain Nil. Unlike some other programming languages
 Citron has no concept of 'undefined' or isset, Nil is actually the
 same as 'undefined' or not set.

 Literal:

 Nil
.BR

.PP
.SS
.B <b> [Nil] isNil </b>

 @see ctr_object_is_nil

 Nil always answers this message with a boolean object 'True'.
.BR

.PP
.SS
.B <b> [Nil] toString </b>

 @see ctr_object_to_string

 Returns the string representation of Nil: 'Nil'.
.BR

.PP
.SS
.B <b> [Nil] toNumber </b>

 @see ctr_object_to_number

 Returns the numerical representation of Nil: 0.
.BR

.PP
.SS
.B <b> [Nil] toBoolean </b>

 @see ctr_object_to_boolean

 Returns the boolean representation of Nil: False.
.BR

.PP
.SS
.B <b> [Nil] unpack: [Ref:string] </b>

 Assigns Nil into Ref
 (Always prefer using algebraic deconstruction assignments: look at section 'Assignment')
.BR

.PP
.SS
.SH
 Object
.B _OBJ_DEF Object
.BR

.PP
.SS
.B This is the base object, the parent of all other objects.
 It contains essential object oriented programming features.
.BR

.PP
.SS
.B <b> Object cnew: [Block] </b>

 Object constructor with some initial parameters.
 Object is passed to the block as me/my
.BR

.PP
.SS
.B <b> Object genAccessors: [String] </b>

 generate reader/writer methods for property.
 creates the property is it doesn't exist
.BR

.PP
.SS
.B <b> Object genReader: [String] </b>

 generate reader method for property.
 creates the property is it doesn't exist
.BR

.PP
.SS
.B <b> Object genWriter: [String] </b>

 generate writer method for property.
 does not create the property is it doesn't exist
.BR

.PP
.SS
.B <b> [Object] unpack: [Object:{Ref*}] </b>

 Element-wise object assign
 (Always prefer using algebraic deconstruction assignments: look at section 'Assignment')
.BR

.PP
.SS
.B <b>[Object] iHash</b>

 fallback hashing
 returns the hash of the object's string form.
.BR

.PP
.SS
.B * <b>[Object] aHash</b>
  *
  * fallback alternate hashing
  * returns the hash of the object's string form.
.BR

.PP
.SS
.B <b>[Object] new hiding:</b>

 Creates a new Object hiding some parameters.
.BR

.PP
.SS
.B <b>[Object] swapRefs: [Object]</b>

 swap two objects with each other.
 Effectively 'xchg %ra, %rb'
.BR

.PP
.SS
.B <b>[Object] type</b>

 Returns a string representation of the type of object.
.BR

.PP
.SS
.B <b>[Object] toString</b>

 Returns a string representation of a generic object.
 This string representation will be:

 [Object]
.BR

.PP
.SS
.B <b>[Object] toNumber</b>

 Errors out. Objects cannot be represented by numbers.
 (default behavior)
.BR

.PP
.SS
.B <b>[Object] toBoolean</b>

 Returns a boolean representation of the object. This basic behavior, part
 of any object will just return True. Other objects typically override this
 behavior with more useful implementations.
.BR

.PP
.SS
.B <b>[Object] equals: [other]</b>

 Tests whether the current instance is the same as
 the argument.

 Alias: =

 Usage:
 object equals: other
.BR

.PP
.SS
.B <b>[Object] id</b>

 returns a unique identifier for the object
.BR

.PP
.SS
.B <b>[Object] myself</b>

 Returns the object itself.
.BR

.PP
.SS
.B <b>[Object] learn: [String] means: [String].</b>

 Teaches any object to repsond to the first specified message just like
 it would upon receiving the second. This allows you to map existing
 responses to new messages. You can use this to translate messages into your native
 language. After mapping, sending the alias message will be just as fast
 as sending the original message. You can use this to create programs
 in your native language without sacrficing performance. Of course the mapping itself
 has a cost, but the mapped calls will be 'toll-free'.

 Usage:

 #in this example we'll map a message to a Dutch word:

 Boolean learn: 'alsWaar:'
         means: 'ifTrue:'.

 (2 > 1) alsWaar: {
   Pen write: 'alsWaar means ifTrue in Dutch'.
 }
.BR

.PP
.SS
.B <b>[Object] do</b>

 Activates 'chain mode'. If chain mode is active, all messages will
 return the recipient object regardless of their return signature.

 Usage:

 a is Array < 'hello' ; 'world' ; True ; Nil ; 666.
 a do pop shift unshift: 'hi', push: 999, done.

 Because of 'chain mode' you can do 'a do pop shift' etc, instead of

 a pop.
 a shift.
 etc..

 The 'do' message tells the object to always return itself and disgard
 the original return value until the message 'done' has been received.
.BR

.PP
.SS
.B <b>[Object] done</b>

 Deactivates 'chain mode'.
.BR

.PP
.SS
.B <b>[Object] message: [String] arguments: [Array]</b>

 Sends a custom or 'dynamic' message to an object. This takes a string containing
 the message to be send to the object and an array listing the arguments at the
 correct indexes. If the array fails to provide the correct indexes this will
 generate an out-of-bounds error coming from the Array object. If something other
 than an Array is provided an error will be thrown as well.

 Usage:

 var str is 'write:'.
 Pen message: 'write:' arguments: (Array < 'Hello World').

 This will print the string 'Hello world' on the screen using a dynamically
 crafted message.
.BR

.PP
.SS
.B <b>[Object] on: [String] do: [Block]</b>

 Makes the object respond to a new kind of message.
 Use the semicolons to indicate the positions of the arguments to be
 passed.

 Usage:

 object on: 'greet' do: { ... }.
 object on: 'between:and:' do: { ... }.
.BR

.PP
.SS
.B <b>[Object] respondTo: [String]</b>

 Variations:

 [Object] respondTo: [String] with: [String]
 [Object] respondTo: [String] with: [String] and: [String]

 Default respond-to implementation, does nothing.
.BR

.PP
.SS
.B <b>[Object] isNil</b>

 Default isNil implementation.

 Always returns boolean object False.
.BR

.PP
.SS
.SH
 Boolean
.B _OBJ_DEF Boolean
.BR

.PP
.SS
.B Boolean

 Literal:

 True
 False
.BR

.PP
.SS
.B <b>[Boolean] unpack: [String:Ref]</b>
 Assign ref to boolean
 (Always prefer using algebraic deconstruction assignments: look at section 'Assignment')
.BR

.PP
.SS
.B <b>[Boolean] = [other]</b>

 Tests whether the other object (as a boolean) has the
 same value (boolean state True or False) as the current one.

 Usage:

 (True = False) ifFalse: { Pen write: 'This is not True!'. }.
.BR

.PP
.SS
.B <b>[Boolean] != [other]</b>

 Tests whether the other object (as a boolean) has the
 same value (boolean state True or False) as the current one.

 Usage:

 (True != False) ifTrue: { Pen write: 'This is not True!'. }.
.BR

.PP
.SS
.B <b>[Boolean] toString</b>

 Simple cast function.
.BR

.PP
.SS
.B <b>[Boolean] break</b>

 Breaks out of the current block and bubbles up to the parent block if
 the value of the receiver equals boolean True.

 Usage:

 (iteration > 10) break. #breaks out of loop after 10 iterations
.BR

.PP
.SS
.B <b>[Boolean] continue</b>

 Skips the remainder of the current block in a loop, continues to the next
 iteration.

 Usage:

 (iteration > 10) continue.
.BR

.PP
.SS
.B <b>[Boolean] ifTrue: [block]</b>

 Executes a block of code if the value of the boolean
 object is True.

 Usage:
 (some expression) ifTrue: { ... }.

 You can also use ifFalse and ifTrue with other objects because the
 Object instance also responds to these messages.
.BR

.PP
.SS
.B <b>[Boolean] ifFalse: [block]</b>

 Executes a block of code if the value of the boolean
 object is True.

 Usage:
 (some expression) ifFalse: { ... }.

 You can also use ifFalse and ifTrue with other objects because the
 Object instance also responds to these messages.
.BR

.PP
.SS
.B <b>[b:Object] or: [Block|Object]</b>

 Evaluates and returns the block if b evaluates to false, else returns b
.BR

.PP
.SS
.B <b>[Boolean] not</b>

 Returns the opposite of the current value.

 Usage:
 True is False not.
.BR

.PP
.SS
.B <b>[Boolean] flip</b>

 'Flips a coin'. Returns a random boolean value True or False.

 Usage:
 coinLandsOn is (Boolean flip).
.BR

.PP
.SS
.B <b>[Boolean] either: [this] or: [that]</b>

 Returns argument #1 if boolean value is True and argument #2 otherwise.

 If either object is a block, it will be executed and its result returned if
 it is supposed to be returned.

 Usage:
 Pen write: 'the coin lands on: ' + (Boolean flip either: 'head' or: 'tail').
 Pen write: 'the coin lands on: ' + (Boolean flip either: {^'head' * 10000.} or: 'tail').
.BR

.PP
.SS
.B <b>[Boolean] & [other]</b>

 Returns True if both the object value is True and the
 argument is True as well.

 Usage:

 a & b
.BR

.PP
.SS
.B <b>[Boolean] ! [other]</b>

 Returns True if the object value is False and the
 argument is False as well.

 Usage:

 a ! b
.BR

.PP
.SS
.B <b>[Boolean] | [other]</b>

 Returns True if either the object value is True or the
 argument is True or both are True.

 Usage:

 a | b
.BR

.PP
.SS
.B <b>[Boolean] ? [other]</b>

 Returns True if either the object value is True or the
 argument is True but not both.

 Usage:

 a ? b
.BR

.PP
.SS
.B <b>[Boolean] toNumber</b>

 Returns 0 if boolean is False and 1 otherwise.
.BR

.PP
.SS
.SH
 Number
.B _OBJ_DEF Number
.BR

.PP
.SS
.B Number

 Literal:

 0
 1
 -8
 2.5

 Represents a number object in Citron.
.BR

.PP
.SS
.B <b>[Number] unpack: [String:Ref]</b>
 Assign ref to number
 (Always prefer using algebraic deconstruction assignments: look at section 'Assignment')
.BR

.PP
.SS
.B <b>[Number] > [other]</b>

 Returns True if the number is higher than other number.
.BR

.PP
.SS
.B <b>[Number] >=: [other]</b>

 Returns True if the number is higher than or equal to other number.
.BR

.PP
.SS
.B <b>[Number] < [other]</b>

 Returns True if the number is less than other number.
.BR

.PP
.SS
.B <b>[Number] <=: [other]</b>

 Returns True if the number is less than or equal to other number.
.BR

.PP
.SS
.B <b>[Number] = [other]</b>

 Returns True if the number equals the other number.
.BR

.PP
.SS
.B <b>[Number] !=: [other]</b>

 Returns True if the number does not equal the other number.
.BR

.PP
.SS
.B <b>[Number] between: [low] and: [high]</b>

 Returns True if the number instance has a value between the two
 specified values.

 Usage:

 q between: x and: y
.BR

.PP
.SS
.B <b>[Number] odd</b>

 Returns True if the number is odd and False otherwise.
.BR

.PP
.SS
.B <b>[Number] even</b>

 Returns True if the number is even and False otherwise.
.BR

.PP
.SS
.B <b>[Number] + [Number]</b>

 Adds the other number to the current one. Returns a new
 number object.
.BR

.PP
.SS
.B <b>[Number] +=: [Number]</b>

 Increases the number ITSELF by the specified amount, this message will change the
 value of the number object itself instead of returning a new number.
.BR

.PP
.SS
.B <b>[Number] - [Number]</b>

 Subtracts the other number from the current one. Returns a new
 number object.
.BR

.PP
.SS
.B <b>[Number] -=: [number]</b>

 Decreases the number ITSELF by the specified amount, this message will change the
 value of the number object itself instead of returning a new number.
.BR

.PP
.SS
.B <b>[Number] * [Number or Block]</b>

 Multiplies the number by the specified multiplier. Returns a new
 number object.
.BR

.PP
.SS
.B <b>[Number] times: [Block]</b>

 Runs the block of code a 'Number' of times.
 This is the most basic form of a loop.

 Usage:

 7 times: { :i Pen write: i. }.

 The example above runs the block 7 times. The current iteration
 number is passed to the block as a parameter (i in this example).
.BR

.PP
.SS
.B <b>[Number] *=: [Number]</b>

 Multiplies the number ITSELF by multiplier, this message will change the
 value of the number object itself instead of returning a new number.

 Usage:

 x is 5.
 x *=: 2. #x is now 10.

 Use this message to apply the operation to the object itself instead
 of creating and returning a new object.
.BR

.PP
.SS
.B <b>[Number] / [Number]</b>

 Divides the number by the specified divider. Returns a new
 number object.
.BR

.PP
.SS
.B <b>[Number] /=: [Number]</b>

 Divides the number ITSELF by divider, this message will change the
 value of the number object itself instead of returning a new number.

 Usage:

 x is 10.
 x /=: 2. #x will now be 5.

 Use this message to apply the operation to the object itself instead
 of generating a new object.
.BR

.PP
.SS
.B <b>[Number] mod: [modulo]</b>

 Returns the modulo of the number. This message will return a new
 object representing the modulo of the recipient.

 Usage:

 x is 11 mod: 3. #x will now be 2

 Use this message to apply the operation of division to the
 object itself instead of generating a new one.
.BR

.PP
.SS
.B <b>[Number] pow: [power]</b>

 Returns a new object representing the
 number to the specified power.

 Usage:

 x is 2 pow: 8. #x will be 256

 The example above will raise 2 to the power of 8 resulting in
 a new Number object: 256.
.BR

.PP
.SS
.B <b>[Number] pos</b>

 Returns a boolean indicating wether the number is positive.
 This message will return a boolean object 'True' if the recipient is
 positive and 'False' otherwise.

 Usage:

 hope is 0.1.
 ( hope pos ) ifTrue: { Pen write: 'Still a little hope for humanity'. }.

 The example above will print the message because hope is higher than 0.
.BR

.PP
.SS
.B <b>[Number] neg</b>

 Returns a boolean indicating wether the number is negative.
 This message will return a boolean object 'True' if the recipient is
 negative and 'False' otherwise. It's the eaxct opposite of the 'positive'
 message.

 Usage:

 hope is -1.
 (hope neg) ifTrue: { Pen write: 'No hope left'. }.

 The example above will print the message because the value of the variable
 hope is less than 0.
.BR

.PP
.SS
.B <b>[Number] max: [other]</b>

 Returns the biggest number of the two.

 Usage:

 x is 6 max: 4. #x is 6
 x is 6 max: 7. #x is 7
.BR

.PP
.SS
.B <b>[Number] min: [other]</b>

 Returns a the smallest number.

 Usage:

 x is 6 min: 4. #x is 4
 x is 6 min: 7. #x is 7
.BR

.PP
.SS
.B <b>[Number] factorial</b>

 Calculates the factorial of a number.
.BR

.PP
.SS
.B <b>[Number] to: [number] step: [step] do: [block]</b>

 Runs the specified block for each step it takes to go from
 the start value to the target value using the specified step size.
 This is basically how you write for-loops in Citron.

 Usage:

 1 to: 5 step: 1 do: { :step Pen write: 'this is step #'+step. }.
.BR

.PP
.SS
.B <b>[Number] to: [number] step: [step]</b>
.BR

.PP
.SS
.B <b>[Number] floor</b>

 Gives the largest integer less than the recipient.

 Usage:

 x is 4.5
 y is x floor. #y will be 4

 The example above applies the floor function to the recipient (4.5)
 returning a new number object (4).
.BR

.PP
.SS
.B <b>[Number] ceil</b>

 Rounds up the recipient number and returns the next higher integer number
 as a result.

 Usage:

 x is 4.5.
 y = x ceil. #y will be 5

 The example above applies the ceiling function to the recipient (4.5)
 returning a new number object (5).
.BR

.PP
.SS
.B <b>[Number] round</b>

 Returns the rounded number.
.BR

.PP
.SS
.B <b>[Number] abs</b>

 Returns the absolute (unsigned, positive) value of the number.

 Usage:

 x is -7.
 y is x abs. #y will be 7

 The example above strips the sign off the value -7 resulting
 in 7.
.BR

.PP
.SS
.B <b>[Number] sqrt</b>

 Returns the square root of the recipient.

 Usage:

 x is 49.
 y is x sqrt. #y will be 7

 The example above takes the square root of 49, resulting in the
 number 7.
.BR

.PP
.SS
.B <b>[Number] exp</b>

 Returns the exponent of the number.
.BR

.PP
.SS
.B <b>[Number] sin</b>

 Returns the sine of the number.
.BR

.PP
.SS
.B <b>[Number] cos</b>

 Returns the cosine of the number.
.BR

.PP
.SS
.B <b>[Number] tan</b>

 Caculates the tangent of a number.
.BR

.PP
.SS
.B <b>[Number] atan</b>

 Caculates the arctangent of a number.
.BR

.PP
.SS
.B <b>[Number] log</b>

 Calculates the logarithm of a number.
.BR

.PP
.SS
.B <b>[Number] shiftRight: [Number]</b>
.BR

.PP
.SS
.B <b>[Number] shiftLeft: [Number]</b>
.BR

.PP
.SS
.B <b>[Number] bitOr: [Number]</b>
.BR

.PP
.SS
.B <b>[Number] bitAnd: [Number]</b>
.BR

.PP
.SS
.B <b>[Number] bitXor: [Number]</b>
.BR

.PP
.SS
.B <b>[Number] toByte</b>

 Converts a number to a single byte.
.BR

.PP
.SS
.B <b>[Number] toString</b>

 Wrapper for cast function.
.BR

.PP
.SS
.B <b>[Number] toBoolean</b>

 Casts a number to a boolean object.
.BR

.PP
.SS
.SH
 String
.B _OBJ_DEF String
.BR

.PP
.SS
.B String

 Literal:

 'Hello World, this is a String.'

 A sequence of characters. In Citron, strings are UTF-8 aware.
 You may only use single quotes. To escape a character use the
 backslash '\' character.
.BR

.PP
.SS
.B <b>[String] isConstructible: [Object]</b>

 returns whether object is constructible from string
.BR

.PP
.SS
.B <b>[String] unpack: [String:Ref]</b>
 Assign ref to string
 (Always prefer using algebraic deconstruction assignments: look at section 'Assignment')
.BR

.PP
.SS
.B <b>[String] bytes</b>

 Returns the number of bytes in a string, as opposed to
 length which returns the number of UTF-8 code points (symbols or characters).
.BR

.PP
.SS
.B <b>[String] = [other]</b>

 Returns True if the other string is the same (in bytes).
.BR

.PP
.SS
.B <b>[String] != [other]</b>

 Returns True if the other string is not the same (in bytes).
.BR

.PP
.SS
.B <b>[String] length</b>

 Returns the length of the string in symbols.
 This message is UTF-8 unicode aware. A 4 byte character will be counted as ONE.
.BR

.PP
.SS
.B <b>[String] + [other]</b>

 Appends other string to self and returns the resulting
 string as a new object.
.BR

.PP
.SS
.B <b>[String] append: [String].</b>

 Appends the specified string to itself. This is different from the '+'
 message, the '+' message adds the specified string while creating a new string.
 Appends on the other hand modifies the original string.

 Usage:

 x is 'Hello '.
 x append: 'World'.
 Pen write: x. #Hello World

 Instead of using the append message you may also use its short form,
 like this:

 x +=: 'World'.
.BR

.PP
.SS
.B <b>[String] multiply: [Number].</b>

 Appends the specified string to itself as many times as [Number]
 alias: *
.BR

.PP
.SS
.B <b>[String] formatObjects: [Array].</b>

 Creates a string with the template format and the specified objects

 Alias: %
 Usage:

 fmt is 'Hello, %s! %d is a number!'
 str is fmt formatObjects: (Array new < 'World', 23).


 formatObjects format specifiers:
 %[opts]<format type>
 opts:
  `:` get the element and use it as a delimiter for the next element (list)
  `.<number>` string padding (works for anything but L)
 types:
  `s` string
  `d` number (citron number : real)
  `L` list
  `%` literal percent sign
  `c|i|x` C number (int) cast to char|int|hex
  `f` C float
   otherwise used as parameter for printf-style format
.BR

.PP
.SS
.B <b>[String] formatMap: [Map]</b>

 format a format string based off a map

 e.g.
  format is 'this \'%{string}\' contains some wierd %{shit}.'.
  fmtd is format formatMap: (Map new put: 'shit' at: 'shit', put: format at: 'string').
  # 'this \'this \'%{string}\' contains some wierd %{shit}.\' contains some weird shit.'
.BR

.PP
.SS
.B <b>[String] from: [position] to: [destination]</b>

 Returns a portion of a string defined by from-to values.
 This message is UTF-8 unicode aware.

 Usage:

 'hello' from: 2 to: 3. #ll
.BR

.PP
.SS
.B <b>[String] from: [start] length: [length]</b>

 Returns a portion of a string defined by from
 and length values.
 This message is UTF-8 unicode aware.

 Usage:

 'hello' from: 2 length: 3. #llo
.BR

.PP
.SS
.B <b>[String] skip: [number]</b>

 Returns a string without the first X characters.
.BR

.PP
.SS
.B <b>[String] sliceFrom: [number] length: [number]</b>

 slice a string from,length and return the sliced. modifies string
.BR

.PP
.SS
.B <b>[String] at: [position]</b>

 Returns the character at the specified position (UTF8 aware).
 You may also use the alias '@'.

 Usage:

 ('hello' at: 2). #l
 ('hello' @ 2). #l
.BR

.PP
.SS
.B <b>[String] byteAt: [position]</b>

 Returns the byte at the specified position (in bytes).
 Note that you cannot use the '@' message here because that will
 return the unicode point at the specified position, not the byte.

 Usage:
 ('abc' byteAt: 1). #98
.BR

.PP
.SS
.B <b>[String] indexOf: [subject]</b>

 Returns the index (character number, not the byte!) of the
 needle in the haystack.

 Usage:

 'find the needle' indexOf: 'needle'. #9
.BR

.PP
.SS
.B <b>[String] reLastIndexOf: [subject]</b>

 Returns the index (character number, not the byte!) of the
 last occurance of needle in the haystack, by regex

 Usage:

 'find the needle' reLastIndexOf: 'n.{2}dle'. #9
.BR

.PP
.SS
.B * <b>[String] reIndexOf: [subject]</b>
*
* Returns the index (character number, not the byte!) of the
* needle in the haystack, by regex
*
* Usage:
*
* 'find the needle' indexOf: 'n.{2}dle'. #9
*
.BR

.PP
.SS
.B <b>[String] startsWith: [String]</b>

 Returns whether the string starts with the arg
.BR

.PP
.SS
.B <b>[String] endsWith: [String]</b>

 Returns whether the string ends with the arg
.BR

.PP
.SS
.B <b>[String] upper</b>

 Returns a new uppercased version of the string.
 Note that this is just basic ASCII case functionality, this should only
 be used for internal keys and as a basic utility function. This function
 DOES NOT WORK WITH UTF8 characters !
.BR

.PP
.SS
.B <b>[String] lower</b>

 Returns a new lowercased version of the string.
 Note that this is just basic ASCII case functionality, this should only
 be used for internal keys and as a basic utility function. This function
 DOES NOT WORK WITH UTF8 characters !
.BR

.PP
.SS
.B <b>[String] lower1st</b>

 Converts the first character of the recipient to lowercase and
 returns the resulting string object.
.BR

.PP
.SS
.B <b>[String] upper1st</b>

 Converts the first character of the recipient to uppercase and
 returns the resulting string object.
.BR

.PP
.SS
.B <b>[String] lastIndexOf: [subject]</b>

 Returns the index (character number, not the byte!) of the
 needle in the haystack.

 Usage:

 'find the needle' lastIndexOf: 'needle'. #9
.BR

.PP
.SS
.B <b>[String] replace: [string] with: [other]</b>

 Replaces needle with replacement in original string and returns
 the result as a new string object.

 Usage:

 'LiLo BootLoader' replace: 'L' with: 'l'. #lilo Bootloader
.BR

.PP
.SS
.B <b>[String] findPattern: [String] do: [Block] options: [String].</b>

 Matches the POSIX or PCRE (depending on the #defines) regular expression in the first argument against
 the string and executes the specified block on every match passing
 an array containing the matches.

 The options parameter can be used to pass specific flags to the
 regular expression engine. As of the moment of writing this functionality
 has not been implemented yet. The only flag you can set at this moment is
 the 'ignore' flag, just a test flag. This flag does not execute the block.

 Usage:

 'hello world' findPattern: '([hl])' do: { :arr
  Pen write: (arr join: '|'), brk.
 } options: ''.

 On every match the block gets executed and the matches are
 passed to the block as arguments. You can also use this feature to replace
 parts of the string, simply return the replacement string in your block.
.BR

.PP
.SS
.B <b>[String] findPattern: [String] do: [Block].</b>

 Same as findPattern:do:options: but without the options, no flags will
 be send to the regex engine.
.BR

.PP
.SS
.B <b>[String] contains: [String]</b>

 Returns True if the other string is a substring.
.BR

.PP
.SS
.B <b>[String] containsPattern: [String].</b>

 Tests the pattern against the string and returns True if there is a match
 and False otherwise.

 Usage:

 var match is 'Hello World' containsPattern: '[:space:]'.
 #match will be True because there is a space in 'Hello World'
.BR

.PP
.SS
.B <b>[String] trim</b>

 Trims a string. Removes surrounding white space characters
 from string and returns the result as a new string object.

 Usage:

 ' hello ' trim. #hello

 The example above will strip all white space characters from the
 recipient on both sides of the text. Also see: leftTrim and rightTrim
 for variations of this message.
.BR

.PP
.SS
.B <b>[String] leftTrim</b>

 Removes all the whitespace at the left side of the string.

 Usage:

 message is ' hello world  '.
 message leftTrim.

 The example above will remove all the whitespace at the left of the
 string but leave the spaces at the right side intact.
.BR

.PP
.SS
.B <b>[String] rightTrim</b>

 Removes all the whitespace at the right side of the string.

 Usage:

 message is ' hello world  '.
 message rightTrim.

 The example above will remove all the whitespace at the right of the
 string but leave the spaces at the left side intact.
.BR

.PP
.SS
.B <b>[String] toNumber</b>

 Converts string to a number.
.BR

.PP
.SS
.B <b>[String] toBoolean</b>

 Converts string to boolean
.BR

.PP
.SS
.B <b>[String] split: [String]</b>

 Converts a string to an array by splitting the string using
 the specified delimiter (also a string).
.BR

.PP
.SS
.B <b>[String] reSplit: [String]</b>

 Converts a string to an array by splitting the string using
 the specified regex (also a string).
 ONLY WITH PCRE
.BR

.PP
.SS
.B <b>[String] characters.</b>

 Splits the string in UTF-8 characters and returns
 those as an array.

 Usage:

 a is 'abc' characters.
 a count. #3
.BR

.PP
.SS
.B <b>[String] toByteArray</b>

 Returns an array of bytes representing the string.
.BR

.PP
.SS
.B <b>[String] fmap: [Block]</b>

 maps a function over the string and returns a string
.BR

.PP
.SS
.B <b>[String] imap: [Block]</b>

 maps a function over the string with indices and returns a string
.BR

.PP
.SS
.B <b>[String] filter: [Block]</b>

 filters a string based on a predicate. returns a string
.BR

.PP
.SS
.B <b>[String] appendByte: [Number].</b>

 Appends a raw byte to a string.
.BR

.PP
.SS
.B <b>[String(length=1)] charSub: [Number | String(length=1)]</b>

 works on the underlaying character.
.BR

.PP
.SS
.B <b>[String(length=1)] charAdd: [Number | String(length=1)]</b>

 works on the underlaying character.
.BR

.PP
.SS
.B <b>[String] htmlEscape</b>

 Escapes HTML chars.
.BR

.PP
.SS
.B <b>[String] hashWithKey: [String]</b>

 Returns the hash of the recipient String using the specified key.
 The default hash in Citron is the SipHash which is also used internally.
 SipHash can protect against hash flooding attacks.
.BR

.PP
.SS
.B <b>[String] eval</b>

 Evaluates the contents of the string as code.

 Usage:

 a is 'Array < 1 ; 2 ; 3' eval.
 x is a @ 2. #3
.BR

.PP
.SS
.B <b>[String] escapeQuotes.</b>

 Escapes all single quotes in a string. Sending this message to a
 string will cause all single quotes (') to be replaced with (\').
.BR

.PP
.SS
.B <b>[String] randomizeBytesWithLength: [Number].</b>

 Returns a randomized string with the specified length using the pool of
 bytes contained in the String object.
.BR

.PP
.SS
.B <b>[String] reverse</b>

 reverse the string
.BR

.PP
.SS
.SH
 Tuple
.B _OBJ_DEF Tuple
.BR

.PP
.SS
.B Tuple

 Literal:

 [ item , item , ... ] or []

 Examples:

 [ 1 , 2 , 3 ]
 []
.BR

.PP
.SS
.SH
 CodeBlock
.B _OBJ_DEF CodeBlock
.BR

.PP
.SS
.B Block

 Literal:

 { parameters (if any) here... code here... }

 each parameter has to be prefixed with
 a colon (:).

 Examples:

 { Pen write: 'a simple code block'. } run.
 { :param Pen write: param. } applyTo: 'write this!'.
 { :a :b ^ a + b. } applyTo: 1 and: 2.
 { :a :b :c ^ a + b + c. } applyTo: 1 and: 2 and: 3.

 to enable context auto-capture,
 qualify captures with the 'const' modifier
.BR

.PP
.SS
.B <b>[Block] unpack: [String:Ref]</b>
 Assign ref to block
 (Always prefer using algebraic deconstruction assignments: look at section 'Assignment')
.BR

.PP
.SS
.B <b>[Block] applyTo: [object]</b>

 Runs a block of code using the specified object as a parameter.
 If you run a block using the messages 'run' or 'applyTo:', me/my will
 refer to the block itself instead of the containing object.

 the passed 'my' will be respected first,
 and if lookup fails, it will be swapped for the block itself
.BR

.PP
.SS
.B <b>[Block] whileTrue: [block]</b>

 Runs a block of code, depending on the outcome runs the other block
 as long as the result of the first one equals boolean True.

 Usage:

 x is 0.
 { ^(x < 6). } whileFalse:
 { x add: 1. }. #increment x until it reaches 6.

 Here we increment variable x by one until it reaches 6.
 While the number x is lower than 6 we keep incrementing it.
 Don't forget to use the return ^ symbol in the first block.
.BR

.PP
.SS
.B <b>[Block] whileFalse: [block]</b>

 Runs a block of code, depending on the outcome runs the other block
 as long as the result of the first one equals to False.

 Usage:

 x is 0.
 { ^(x > 5). }
 whileFalse: { x add: 1. }. #increment x until it reaches 6.

 Here we increment variable x by one until it reaches 6.
 While the number x is not higher than 5 we keep incrementing it.
 Don't forget to use the return ^ symbol in the first block.
.BR

.PP
.SS
.B <b>[Block] run</b>

 Sending the unary message 'run' to a block will cause it to execute.
 The run message takes no arguments, if you want to use the block as a function
 and send arguments, consider using the applyTo-family of messages instead.
 This message just simply runs the block of code without any arguments.

 Usage:

 { Pen write: 'Hello World'. } run. #prints 'Hello World'

 The example above will run the code inside the block and display
 the greeting.
.BR

.PP
.SS
.B <b>[Block] set: [name] value: [object]</b>

 Sets a variable in a block of code. This how you can get closure-like
 functionality.

 Usage:

 shout is { Pen write: (my message + '!!!'). }.
 shout set: 'message' value: 'hello'.
 shout run.

 Here we assign a block to a variable named 'shout'.
 We assign the string 'hello' to the variable 'message' inside the block.
 When we invoke the block 'shout' by sending the run message without any
 arguments it will display the string: 'hello!!!'.

 Similarly, you could use this technique to create a block that returns a
 block that applies a formula (for instance simple multiplication) and then set the
 multiplier to use in the formula. This way, you could create a block
 building 'formula blocks'. This is how you implement & use closures
 in Citron.

 There is no need to capture values with this message if you don't require the
 name of the variable to be anything specific.
 In such circumstances, you may use the automatic capture qualifier `const`
 to capture the value directly where it is needed.
.BR

.PP
.SS
.B <b>[Block] error: [object].</b>

 Sets error flag on a block of code.
 This will throw an error / exception.
 You can attach an object to the error, for instance
 an error message.

 Example:

 {
   thisBlock error: 'oops!'.
 } catch: { :errorMessage
   Pen write: errorMessage.
 }, run.
.BR

.PP
.SS
.B <b>[Block] catch: [otherBlock]</b>

 Associates an error clause to a block.
 If an error (exception) occurs within the block this block will be
 executed, and its return substituted for the result of the expression

 Example:

 #Raise error on division by zero.
 {
    var z is 4 / 0.
 } catch: { :errorMessage
    Pen write: e, brk.
 }, run.
.BR

.PP
.SS
.B <b>[Block] catch: [otherBlock] type: [Object]</b>

 Associates an error clause to a block.
 If the specified exception occurs within the block this block will be
 executed, and its return substituted for the result of the expression

 Example:

 #Raise error on division by zero.
 {
    var z is 4 / 0.
 } catch: { :errorMessage
    Pen write: e, brk.
 } type: String, run.
.BR

.PP
.SS
.B <b>[Block] toString</b>

 Returns a string representation of the Block. This basic behavior, part
 of any object will just return [Block]. Other objects typically override this
 behavior with more useful implementations.
.BR

.PP
.SS
.SH
 Array
.B _OBJ_DEF Array
.BR

.PP
.SS
.B [Array] new

 Creates a new Array.

 Usage:

 a is Array new.

 or, the short form:

 a is Array ← 1 ; 2 ; 3.  

 or (if you prefer ASCII only symbols):

 a is Array < 1 ; 2 ; 3.
.BR

.PP
.SS
.B [Array] copy

 shallow copy of the array
.BR

.PP
.SS
.B [Array] type

 Returns the string 'Array'.
.BR

.PP
.SS
.B [Array] push: [Element]

 Pushes an element on top of the array.

 Usage:

 numbers is Array new.
 numbers push: 3.
.BR

.PP
.SS
.B [Array] min

 Returns the minimum value from an array.

 Usage:

 a is Array ← 8 ; 4 ; 2 ; 16.  
 m is a min. #2
.BR

.PP
.SS
.B [Array] all [: [Block]]

 Returns whether all the objects inside the array are truth-y.

 Usage:

 a is Array ← True ; False ; False.  
 m is a all. #False
.BR

.PP
.SS
.B [Array] any [: [Block]]

 Returns whether any of the objects inside the array are truth-y.

 Usage:

 a is Array ← True ; False ; False.  
 m is a any. #True
.BR

.PP
.SS
.B [Array] max

 Returns the maximum value from an array.

 Usage:

 a is Array ← 8 ; 4 ; 2 ; 16.  
 m is a max. #16
.BR

.PP
.SS
.B [Array] sum

 Takes the sum of an array. This message will calculate the
 sum of the elements in the array.

 Usage:

 a is Array ← 1 ; 2 ; 3.  
 s is a sum. #6

 In the example above, the sum of array will be stored in s and
 it's value will be 6.
.BR

.PP
.SS
.B [Array] product

 Takes the product of an array. On receiving this message, the
 Array recipient object will calculate the product of its
 numerical elements.

 Usage:

 a is Array ← 2 ; 4 ; 8.  
 p is a product. #64

 In the example above, the product of the array will be calculated
 because the array receives the message 'product'. The product of the elements
 ( 2 * 4 * 8 = 64 ) will be stored in p.
.BR

.PP
.SS
.B [Array] * [o:Number | Array]

 Repeats the array o times if o is a number, and generates an array multiplication
 for myself and o if o is an array
.BR

.PP
.SS
.B [Array] intersperse: [o: Object]

 places an 'o' between all array elements
 returns an array
.BR

.PP
.SS
.B [Array] map: [Block].

 Iterates over the array. Passing each element as a key-value pair to the
 specified block.
 The map message will pass the following arguments to the block, the key,
 the value and a reference to the array itself. The last argument might seem
 redundant but allows for a more functional programming style.

 Usage:

 files map: showName.
 files map: {
   :key :filename :files
   Pen write: filename, brk.
 }.
.BR

.PP
.SS
.B [Array] each: [Block].

  Alias for [Array] map: [Block].
.BR

.PP
.SS
.B [Array] map_v: [Block].

 Iterates over the array. Passing each element as a value to the
 specified block.
 The map message will pass only the value.

 Usage:

 files map_v: showName.
 files map_v: {
   :filename
   Pen write: filename, brk.
 }.
.BR

.PP
.SS
.B * [Array] each_v: [Block].
*
*  Alias for [Array] map_v: [Block].
.BR

.PP
.SS
.B [Array] from: [Number] lengthMax: [Number]

  makes n-tuple-wise iterations
 If `fill` is specified, that will be used to fill when we are elements short
 Else Nil will be passed
.BR

.PP
.SS
.B [Array] every: [Number] do: [Block] fill: [Object].
 [Array] every: [Number] do: [Block].

  makes n-tuple-wise iterations
 If `fill` is specified, that will be used to fill when we are elements short
 Else Nil will be passed
.BR

.PP
.SS
.B [Array] chunks: [Number]
 [Array] chunks: [Number] fill: [Object]
  makes a bunch of n-tuples
 If `fill` is specified, that will be used to fill when we are elements short
 Else Nil will be passed
.BR

.PP
.SS
.B [Array] ← [Element1] ; [Element2] ; ...  

 Creates a new instance of an array and initializes this
 array with a first element, useful for literal-like Array
 notations.

 Usage:

 a is Array ← 1 ; 2 ; 3.  

 or if ASCII-only is preferred:

 a is Array < 1 ; 2 ; 3.

 Note that the ; symbol here is an alias for 'push:'.
.BR

.PP
.SS
.B [Array] unshift: [Element].

 Unshift operation for array.
 Adds the specified element to the beginning of the array.

 Usage:

 a is Array new.
 a push: 1.
 a unshift: 3. #now contains: 3,1
.BR

.PP
.SS
.B [Array] reverse
.BR

.PP
.SS
.B [Array] join: [Glue].

 Joins the elements of an array together in a string
 separated by a specified glue string.

 Usage:

 collection is Array new.
 collection push: 1, push: 2, push 3.
 collection join: ','. # results in string: '1,2,3'
.BR

.PP
.SS
.B [Array] at: [Index]

 Returns the element in the array at the specified index.
 Note that the fisrt index of the array is index 0.

 Usage:

 fruits is Array ← 'apples' ; 'oranges' ; 'bananas'.  
 fruits at: 1. #returns 'oranges'
.BR

.PP
.SS
.B [Array] indexOf: [Object]

 Returns the index of the first occurence of object
 -1 if not found
.BR

.PP
.SS
.B [Array] contains: [Object]

 Returns whether the array contains the object or not
.BR

.PP
.SS
.B [Array] @ [Index]

 Alias for [Array] at: [Index]
.BR

.PP
.SS
.B [Array] put: [Element] at: [Index]

 Puts a value in the array at the specified index.
 Array will be automatically expanded if the index is higher than
 the maximum index of the array, unless the array is immutable

 Usage:

 fruits is Array new.
 fruits put: 'apples' at: 5.
.BR

.PP
.SS
.B [Array] pop

 Pops off the last element of the array.
.BR

.PP
.SS
.B [Array] shift

 Shifts off the first element of the array.
.BR

.PP
.SS
.B [Array] count

 Returns the number of elements in the array.
.BR

.PP
.SS
.B [Array] from: [Begin] length: [End]

 Copies part of an array indicated by from and to and
 returns a new array consisting of a copy of this region.
.BR

.PP
.SS
.B [Array] skip: [n:Number]

 Skips the first n elements of the array
.BR

.PP
.SS
.B * [Array] zip
*
* zip array.
* Works on the inner elements of the array.
* If the element is an array, it is expanded exactly once.
* And if the element is not an array, it is used as-is
*
.BR

.PP
.SS
.B [Array] zipWith: [Block]

 zip array according to the return of the block
 Works on the inner elements of the array.
 If the element is an array, it is expanded exactly once.
 And if the element is not an array, it is used as-is
.BR

.PP
.SS
.B [Array] head
 see also (tail, init, last)

 returns the first element of the array
 Does generate exceptions when array is empty
.BR

.PP
.SS
.B [Array] tail
 see also (head, init, last)

 returns all of the array sans the first element
 Does not generate exceptions when array is empty
.BR

.PP
.SS
.B [Array] init
 see also (head, tail, last)

 returns all of the array sans the last element
 Does not generate exceptions when array is empty
.BR

.PP
.SS
.B [Array] last
 see also (head, tail, init)

 returns all of the array sans the last element
 Does generate exceptions when array is empty
.BR

.PP
.SS
.B [Array] + [Array]

 Returns a new array, containing elements of itself and the other
 array.
.BR

.PP
.SS
.B Array fmap: [Block]

 Maps a function over the block. this function should accept a single value.

 [1,2,3,4] fmap: {:v ^v + 1.}. #=> Array new < 2 ; 3 ; 4 ; 5
.BR

.PP
.SS
.B Array imap: [Block]

 Maps a function over the block. this function should accept an index and a value.

 [1,2,3,4] imap: {:i:v ^v + i.}. #=> Array new < 1 ; 3 ; 5 ; 7
.BR

.PP
.SS
.B Array foldl: [Block] accumulator: [Object]

 reduces an array according to a block (which takes an accumulator and the value, and returns the next acc) from the left (index 0)

 ([1,2,3,4]) foldl: {:acc:v ^acc + v.} accumulator: 0. #=> Equivalent to ([1,2,3,4]) sum.
.BR

.PP
.SS
.B [Array] filter: [Block<i,v>]

 Include the element iff block returns True for the element
.BR

.PP
.SS
.B [Array] filter_v: [Block<v>]

 Include the element iff block returns True for the element
.BR

.PP
.SS
.B [Array] fmap: [Block] from: [Block|Array|Map|supports `items`] [filter: [Block]]
 @Experimental
 list comprehension
.BR

.PP
.SS
.B [Array] from: [Block|Array|Map|supports `each`] [if: [Block]]
 @Experimental
 list comprehension
.BR

.PP
.SS
.B [Array] unpack: [Array:{Ref:string}]
 Element-wise assign
 (Always prefer using algebraic deconstruction assignments: look at section 'Assignment')
.BR

.PP
.SS
.B [Array] sort: [Block]

 Sorts the contents of an array using a sort block.
 Uses qsort.
.BR

.PP
.SS
.B [Array] toString

 Returns a string representation of the array and its contents.
 This representation will be encoded in the Citron language itself and is
 therefore evallable.

 Usage:

 a is Array ← 'hello' ; 'world'.  
 b is a toString.
 c is b eval.
 x is c @ 1. #world

 toString messages are implicitly send by some objects, for instance when
 attempting to write an Array using a Pen.

 You can also use the alias 'serialize'.
.BR

.PP
.SS
.B [Array] serialize

 Alias for [Array] toString.

 See 'Map serialize' for the reason for this alias.
.BR

.PP
.SS
.SH
 Map
.B _OBJ_DEF Map
.BR

.PP
.SS
.B Map

 Creates a Map object.

 Usage:

 files is Map new.
 files put: 'readme.txt' at: 'textfile'.
.BR

.PP
.SS
.B [Map] type

 Returns the string 'Map'.
.BR

.PP
.SS
.B [Map] put: [Element] at: [Key]

 Puts a key-value pair in a map.

 Usage:

 map put: 'hello' at: 'world'.
.BR

.PP
.SS
.B [Map] deleteAt: [key]

 deletes an entry (Noop if not in the map)

 Usage:

 map deleteAt: 'world'.
.BR

.PP
.SS
.B [Map] at: [Key]

 Retrieves the value specified by the key from the map.
.BR

.PP
.SS
.B [Map] @ [Key]

 Alias for [Map] at: [Key].
.BR

.PP
.SS
.B [Map] count

 Returns the number of elements in the map.
.BR

.PP
.SS
.B [Map] each: [Block]

 Iterates over the map, passing key-value pairs to the specified block.
 Note that within an each/map block, 'me' and 'my' refer to the collection.
.BR

.PP
.SS
.B [Map] fmap: [Block<key,value>]

 Iterates over the map, passing the key and the value to the function, and replacing the value with the result
 (Or itself if a value is not returned)
.BR

.PP
.SS
.B [Map] kvmap: [Block]

 Iterates over the map, passing a tuple of [key, value] to the specified block.
 And constructs a new Map based off the returned kv-tuple
 Note that within an each/map block, 'me' and 'my' refer to the collection.
.BR

.PP
.SS
.B [Map] kvlist: [Block]

 Iterates over the map, passing a tuple of [key, value] to the specified block.
 And constructs a new list based off the returned kv-tuple
 Note that within an each/map block, 'me' and 'my' refer to the collection.
.BR

.PP
.SS
.B [Map] flip

 flips the keys and the values of the map. (same-value keys will be overwritten)
.BR

.PP
.SS
.B [Map] toString

 Returns a string representation of a map encoded in Citron itself.
 This will give you an
 evallable representation of the map and all of its members.

 Usage

 m is (Map new) put: 'hello' at: 'world'.
 x is m toString
 m is x eval.

 The toString method is automatically invoked when attempting to
 print a Map:

 Pen write: (Map new). #prints Map new.

 You can also use the alias 'serialize'.
.BR

.PP
.SS
.B * [Map] serialize
*
* Alias for [Map] toString.
* A toString message, sometimes implicitly send by other messages like
* 'Pen write:' will give you a serialized version of the Map or Array.
* This is far more useful than a 'dumb' textual description of the object like
* 'array' or 'object'. However, when working with very large Maps or Arrays
* accidentally dumping the entire contents can be annoying, in this case you can
* override the toString behaviour but you don't have to remap the original, you
* can just use this alias. Also, this alias can be used if you want to make
* the serialization more explicit.
.BR

.PP
.SS
.B [Map] unpack: [Map:{Ref:AlternativeName}]
Key-wise assign
Give alternative names as the values of the constructor

e.g. (Map new put: 'Hello' at: 'test0', put: 'World' at: 'test1') unpack: (Map cnew: {my test0 is 'a'. my test1 is 'b'.})

(Always prefer using algebraic deconstruction assignments: look at section 'Assignment')
.BR

.PP
.SS
.B [Map] contains: [Object]

 check if map contains key
.BR

.PP
.SS
.SH
 Iterator
.B _OBJ_DEF Iterator
.BR

.PP
.SS
.B Iterator

 Iterator (range), an object that supports next and current,
 and steps through some values before (optionally) reaching an end
.BR

.PP
.SS
.B [Iterator] setFunc: [f:Block]

 sets the iterator step function.
.BR

.PP
.SS
.B [Iterator] repeat: [Object]

 An iterator that keeps repeating the same value.
.BR

.PP
.SS
.B [Iterator] rangeFrom: [f:Number] to: [t:Number] step: [s:Number]

 makes a range iterator in range [f,t] with steps of s
.BR

.PP
.SS
.B [Iterator] rangeFrom: [f:(supports +)] step: [s:(supports +)]

 makes a range iterator in range [f,inf) with steps of s
 works on all objects that support the message '+'
.BR

.PP
.SS
.B [Iterator] next

 gives the next value or breaks (to signal the end of the iterator)
.BR

.PP
.SS
.B [Iterator] each: [Block<nil,value,iterator>]

 Runs the block for each value in the iterator while stepping through it
 Sends Nil for the index.
.BR

.PP
.SS
.B [Iterator] each_v: [Block<value>]

 Runs the block for each value in the iterator while stepping through it
.BR

.PP
.SS
.B [Iterator] fmap: [b:Block<value>]
 Equivalent to [Array] fmap: [Block<value>]

 transforms the iterator with the block to another iterator
This function does not evaluate anything from the iterator
.BR

.PP
.SS
.B [Iterator] filter: [b:Block<nil,value>]

 XXX XXX XXX :: Unimplemented
 Equivalent to [Array] filter: [Block<index,value>]

 filters the iterator with the block's return value as the predicate to an array
 this function does not evaluate anything from the iterator.
.BR

.PP
.SS
.B [Iterator] foldl: [Block] accumulator: [Object]

 reduces an iterator according to a block (which takes an accumulator and the value, and returns the next acc) from the left (index 0)
.BR

.PP
.SS
.B [Iterator] count

 Steps through the iterator until it ends and returns the count.
 resets the state of the iterator
.BR

.PP
.SS
.B [Iterator] take: [t:Number]

 takes at most <t> number of elements from the Iterator
.BR

.PP
.SS
.B [Iterator] takeWhile: [predicate:Block]

 takes values as long as predicate returns true.
.BR

.PP
.SS
.B [Iterator] endBlock

 returns a block that throws an IteratorEndException.
.BR

.PP
.SS
.B [Iterator] endIf: [clause:Block]

 ends the Iterator if clause returns True
.BR

.PP
.SS
.B [Iterator] toArray

 Collects all of the iterator values into an array
.BR

.PP
.SS
.B [Iterator] skip: [n:Number]

 skips n iterations and returns the nth value
 does not reset the evaluation. (iterator will advance to index n)
.BR

.PP
.SS
.SH
 File
.B _OBJ_DEF File
.BR

.PP
.SS
.B File

 Represents a File object.
 Creates a new file object based on the specified path.

 Usage:

 File new: '/example/path/to/file.txt'.
.BR

.PP
.SS
.B [File] tempFileLike: [String]

 Represents a File object.
 Creates a new temporary file object based on the specified path.
 replacing XXXX with some chars.
 Usage:

 File tempFileLike: '/example/path/to/fileXXXXXXXX'.
.BR

.PP
.SS
.B [File] path

 Returns the path of a file. The file object will respond to this
 message by returning a string object describing the full path to the
 recipient.
.BR

.PP
.SS
.B [File] unpack: [String:Ref]
 Assigns the file instance to the reference
 (Always prefer using algebraic deconstruction assignments: look at section 'Assignment')
.BR

.PP
.SS
.B [File] realPath

 Returns the real path of a file. The file object will respond to this
 message by returning a string object describing the absolute path to the
 recipient.
.BR

.PP
.SS
.B [File] read

 Reads contents of a file. Send this message to a file to read the entire contents in
 one go. For big files you might want to prefer a streaming approach to avoid
 memory exhaustion (see readBytes etc).

 Usage:

 data is File new: '/path/to/mydata.csv', read.

 In the example above we read the contents of the entire CSV file callled mydata.csv
 in the variable called data.
.BR

.PP
.SS
.B [File] write: [String]

 Writes content to a file. Send this message to a file object to write the
 entire contents of the specified string to the file in one go. The file object
 responds to this message for convience reasons, however for big files it might
 be a better idea to use the streaming API if possible (see readBytes etc.).

 data is '<xml>hello</xml>'.
 File new: 'myxml.xml', write: data.

 In the example above we write the XML snippet in variable data to a file
 called myxml.xml in the current working directory.
.BR

.PP
.SS
.B [File] append: [String]

 Appends content to a file. The file object responds to this message like it
 responds to the write-message, however in this case the contents of the string
 will be appended to the existing content inside the file.
.BR

.PP
.SS
.B [File] exists

 Returns True if the file exists and False otherwise.
.BR

.PP
.SS
.B [File] include

 Includes the file as a piece of executable code.
.BR

.PP
.SS
.B [File] runHere

 Includes the file as a piece of executable code.
.BR

.PP
.SS
.B [File] delete

 Deletes the file.
.BR

.PP
.SS
.B [File] size

 Returns the size of the file.
.BR

.PP
.SS
.B [File] open: [string]

 Open a file with using the specified mode.

 Usage:

 f is File new: '/path/to/file'.
 f open: 'r+'. #opens file for reading and writing

 The example above opens the file in f for reading and writing.
.BR

.PP
.SS
.B [File] close.

 Closes the file represented by the recipient.

 Usage:

 f is File new: '/path/to/file.txt'.
 f open: 'r+'.
 f close.

 The example above opens and closes a file.
.BR

.PP
.SS
.B [File] readBytes: [Number].

 Reads a number of bytes from the file.

 Usage:

 f is File new: '/path/to/file.txt'.
 f open: 'r+'.
 x is f readBytes: 10.
 f close.

 The example above reads 10 bytes from the file represented by f
 and puts them in buffer x.
.BR

.PP
.SS
.B [File] writeBytes: [String].

 Takes a string and writes the bytes in the string to the file
 object. Returns the number of bytes actually written.

 Usage:

 f is File new: '/path/to/file.txt'.
 f open: 'r+'.
 n is f writeBytes: 'Hello World'.
 f close.

 The example above writes 'Hello World' to the specified file as bytes.
 The number of bytes written is returned in variable n.
.BR

.PP
.SS
.B [File] seek: [Number].

 Moves the file pointer to the specified position in the file
 (relative to the current position).

 Usage:

 file open: 'r', seek: 10.

 The example above opens a file for reading and moves the
 pointer to position 10 (meaning 10 bytes from the beginning of the file).
 The seek value may be negative.
.BR

.PP
.SS
.B [File] rewind.

 Rewinds the file. Moves the file pointer to the beginning of the file.

 Usage:

 file open: 'r'.
 x is file readBytes: 10. #read 10 bytes
 file rewind.        #rewind, set pointer to begin again
 y is file readBytes: 10. #re-read same 10 bytes

 The example above reads the same sequence of 10 bytes twice, resulting
 in variable x and y being equal.
.BR

.PP
.SS
.B [File] end.

 Moves the file pointer to the end of the file. Use this in combination with
 negative seek operations.

 Usage:

 file open: 'r'.
 file end.
 x is file seek: -10, readBytes: 10.

 The example above will read the last 10 bytes of the file. This is
 accomplished by first moving the file pointer to the end of the file,
 then putting it back 10 bytes (negative number), and then reading 10
 bytes.
.BR

.PP
.SS
.SH
 Broom
.B _OBJ_DEF Broom
.BR

.PP
.SS
.B Broom

 GarbageCollector, to invoke use:

 [Broom] sweep.
.BR

.PP
.SS
.B [Broom] dust

 Returns the number of objects collected.
.BR

.PP
.SS
.B [Broom] unpack: [String:Ref]
 assigns the instance to the reference
 (Always prefer using algebraic deconstruction assignments: look at section 'Assignment')
.BR

.PP
.SS
.B [Broom] objectCount

 Returns the total number of objects considered in the latest collect
 cycle.
.BR

.PP
.SS
.B [Broom] keptCount

 Returns the total number of objects that have been marked during the
 latest cycle and have therefore been allowed to stay in memory.
.BR

.PP
.SS
.B [Broom] keptAlloc

 Returns the amount of allocated memory.
.BR

.PP
.SS
.B [Broom] stickyCount

 Returns the total number of objects that have a sticky flag.
 These objects will never be removed.
.BR

.PP
.SS
.B [Broom] memoryLimit

 Sets the memory limit, if this limit gets exceeded the program will produce
 an out-of-memory error.
.BR

.PP
.SS
.B [Broom] mode: [Number]

 Selects mode of operation for GC.

 Available Modes:
 0 - No Garbage Collection
 1 - Activate Garbage Collector
 4 - Activate Garbage Collector for every single step (testing only)
.BR

.PP
.SS
.B [Broom] autoAlloc: [Boolean]

 Set whether the max allowed memory cap is enforced or not
.BR

.PP
.SS
.SH
 Shell
.B _OBJ_DEF Shell
.BR

.PP
.SS
.B [Shell] call: [String]

 Performs a Shell operation. The Shell object uses a fluid API, so you can
 mix shell code with programming logic. For instance to list the contents
 of a directory use:

 Shell ls

 This will output the contents of the current working directly, you
 can also pass keyword messages like so:

 Shell echo: 'Hello from the Shell!'.

 The example above will output the specified message to the console.
 Every message you send will be turned into a string and dispatched to
 the 'call:' message.
.BR

.PP
.SS
.B [Shell] unpack: [String:Ref]
 assigns the instance to the reference
 (Always prefer using algebraic deconstruction assignments: look at section 'Assignment')
.BR

.PP
.SS
.SH
 Slurp
.B _OBJ_DEF Slurp
.BR

.PP
.SS
.B [Slurp] obtain.

 Obtains the string generated using the Slurp object.
 A Slurp object collects all messages send to it and flushes its buffer while
 returning the resulting string after an 'obtain' message has been received.

 Usage:

 Slurp hello world.
 Pen write: (Slurp obtain).

 This will output: 'hello world'.
 Use the Slurp object to integrate verbose shell commands, other programming languages
 (like SQL) etc into your main program without overusing strings.

 Example:

 query select: '*', from users where: 'id = 2'.

 Note that we can't use the = and * unfortunately right now
 because = is also a method in the main object. While * can be used
 theoretically, it expects an identifier, and 'from' is not a real
 identifier, it's just another unary message, so instead of using a binary
 * we simply use a keyword message select: with argument '*' and then
 proceed our SQL query with a comma (,) to chain the rest.
 This is an artifact of the fact that the DSL has to be embedded within
 the language of Citron. However even with these restrictions (some of which might be
 alleviated in future versions) it's quite comfortable and readable to interweave
 an external language in your Citron script code.
.BR

.PP
.SS
.SH
 Program
.B _OBJ_DEF Program
.BR

.PP
.SS
.B [Program] argument: [Number]

 Obtains an argument from the CLI invocation.
.BR

.PP
.SS
.B [Program] argCount

 Returns the number of CLI arguments passed to the script.
.BR

.PP
.SS
.B [Program] unpack: [String:Ref]
 assigns the instance to the reference
 (Always prefer using algebraic deconstruction assignments: look at section 'Assignment')
.BR

.PP
.SS
.B [Program] exit

 Exits program immediately.
.BR

.PP
.SS
.B [Program] env: [String]

 Returns the value of an environment variable.

 Usage:

 x is Command env: 'MY_PATH_VAR'.
.BR

.PP
.SS
.B [Program] env: [Key] val: [Value]

 Sets the value of an environment variable.
.BR

.PP
.SS
.B [Program] changeDirectory: [path:String]

 chdir to path, returns the past directory on success
.BR

.PP
.SS
.B [Program] waitForInput

 Ask a question on the command-line, resumes program
 only after pressing the enter key.
 Only reads up to 100 characters.

 Usage:

 Pen write: 'What is your name ?'.
 x is Command waitForInput.
 Pen write: 'Hello ' + x + ' !', brk.

 The example above asks the user for his/her name and
 then displays the input received.
.BR

.PP
.SS
.B [Program] getCharacter

 reads a character from STDIN.
 Will only return after reading one ASCII character and a return.
.BR

.PP
.SS
.B [Program] input.

 Reads all raw input from STDIN.

 Usage (for instance to read raw CGI post):

 post is Program input.
.BR

.PP
.SS
.B [Program] forbidShell

 This method is part of the security profiles feature of Citron.
 This will forbid the program to execute any shell operations. All
 external libraries and plugins are assumed to respect this setting as well.

 Usage:

 Program forbidShell.
.BR

.PP
.SS
.B [Program] forbidFileWrite

 This method is part of the security profiles feature of Citron.
 This will forbid the program to modify, create or delete any files. All
 external libraries and plugins are assumed to respect this setting as well.

 Usage:

 Program forbidFileWrite.
.BR

.PP
.SS
.B [Program] forbidFileRead

 This method is part of the security profiles feature of Citron.
 This will forbid the program to read any files. In fact this will prevent you from
 creating the file object at all.
 This will also prevent you from reading environment variables.
 All external libraries and plugins are assumed to respect this setting as well.
 Forbidding a program to read files also has the effect to forbid including other
 source files.

 Usage:

 Program forbidFileRead.
.BR

.PP
.SS
.B [Program] forbidInclude

 This method is part of the security profiles feature of Citron.
 This will forbid the program to include any other files. All
 external libraries and plugins are assumed to respect this setting as well.

 Usage:

 Program forbidInclude.
.BR

.PP
.SS
.B [Program] forbidFork.
.BR

.PP
.SS
.B [Program] remainingMessages: [Number]

 This method is part of the security profiles feature of Citron.
 This will initiate a countdown for the program, you can specify the maximum quota of
 messages the program may process, once this quota has been exhausted the program will
 be killed entirely (no exception).

 Usage:

 Program remainingMessages: 100.
.BR

.PP
.SS
.B [Program] flush.

 Flushes the STDOUT output buffer.
.BR

.PP
.SS
.B [Program] new: [Block].

 Forks the program into two programs.
 Creates another program that will run at the same time as the
 current program. Both the parent and the child will obtain a reference
 to the newly created program. The child will obtain a reference to
 itself passed as a parameter to the code block while the parent will
 obtain its version of the program instance as the return value of the
 new: message.

 Note that spawning a new program will leak memory.
 The file descriptors used to setup communication between parent and
 child will be removed when the main program ends but any newly created
 program will add a descriptor pair to the set. This is a limitation
 in the current implementation.

 Usage:

 child is Program new: { :program
 	Pen write: 'Child', brk.
 }.
 Pen write: 'Parent'.
.BR

.PP
.SS
.B [Program] message: [String].

 Sends a message to another program, i.e. a child or a parent that is
 running at the same time.
.BR

.PP
.SS
.B [Program] listen: [Block].

 Stops the current flow of the program and starts listening for
 messages from other programs that are running at the same time.
 Upon receiving a message, the specified block will be invocated
 and passed the message that has been received.
.BR

.PP
.SS
.B [Program] join

 Rejoins the program with the main program.
 This message will cause the current program to stop and wait
 for the child program to end.
.BR

.PP
.SS
.B [Object] fromComputer: [String] [port: [Number] [inet6: [Boolean]]]

 Creates a remote object from the server specified by the
 ip address.
.BR

.PP
.SS
.B [Program] port: [Number].

 Sets the port to use for remote connections.
.BR

.PP
.SS
.B [Program] connectionLimit: [Number].

 Sets the maximum number of connections and requests that will be
 accepted by the current program.
.BR

.PP
.SS
.B [Program] serve: [Object].

 Serves an object. Client programs can now communicate with this object
 and send messages to it.
.BR

.PP
.SS
.B [Program] serve_ipv4: [Object].

 Serves an object. Client programs can now communicate with this object
 and send messages to it. starts the server with an ipv4 binding
.BR

.PP
.SS
.SH
 Dice
.B _OBJ_DEF Dice
.BR

.PP
.SS
.B [Dice] rollWithSides: [Number]

 Rolls the dice, generates a pseudo random number.
.BR

.PP
.SS
.B [Dice] roll

 Rolls a standard dice with 6 sides.
.BR

.PP
.SS
.B [Dice] rawRandomNumber

 Generates a random number, the traditional way (like rand()).
.BR

.PP
.SS
.SH
 Clock
.B _OBJ_DEF Clock
.BR

.PP
.SS
.B [Clock] wait: [Number]

 Waits X useconds* depends on qualification
 Quals:
 ns[ecs] nanosecs
 us[ecs] microsecs
 ms[ecs] milisecs
 se[cs] seconds
 mi[nutes] minutes
 ho[urs] hours
.BR

.PP
.SS
.B [Clock] new: [Number].

 Creates a new clock instance from a UNIX time stamp.
.BR

.PP
.SS
.B [Clock] like: [Clock]

 Syncs a clock. Copies the time AND zone from the other clock.

 Usage:
 clock is Clock new: timeStamp.
 copyClock is Clock new like: clock.
.BR

.PP
.SS
.B [Clock] zone: [String]

 Sets the time zone of the clock.
.BR

.PP
.SS
.B [Clock] zone

 Returns time zone of the clock.
.BR

.PP
.SS
.B [Clock] zone: [Number]

 Sets the year of the clock.
.BR

.PP
.SS
.B [Clock] zone: [Number]

 Sets the month of the clock.
.BR

.PP
.SS
.B [Clock] zone: [Number]

 Sets the day of the clock.
.BR

.PP
.SS
.B [Clock] zone: [Number]

 Sets the hour of the clock.
.BR

.PP
.SS
.B [Clock] zone: [Number]

 Sets the minute of the clock.
.BR

.PP
.SS
.B [Clock] zone: [Number]

 Sets the second of the clock.
.BR

.PP
.SS
.B [Clock] year

 Returns year of the clock.
.BR

.PP
.SS
.B [Clock] month

 Returns month of the clock.
.BR

.PP
.SS
.B [Clock] day

 Returns day of the clock.
.BR

.PP
.SS
.B [Clock] hour

 Returns hour of the clock.
.BR

.PP
.SS
.B [Clock] minute

 Returns minute of the clock.
.BR

.PP
.SS
.B [Clock] second

 Returns second of the clock.
.BR

.PP
.SS
.B [Clock] yearday

 Returns day number of the year.
.BR

.PP
.SS
.B [Clock] weekday

 Returns the week day number of the clock.
.BR

.PP
.SS
.B [Clock] time.

 Returns the UNIX time stamp representation of the time.
 Note: this is the time OF CREATION OF THE OBJECT. To get the actual time use:

 [Clock] new time.
.BR

.PP
.SS
.B [Clock] week

 Returns the week number of the clock.
.BR

.PP
.SS
.B [Clock] format: [String]

 Returns a string describing the date and time represented by the clock object
 according to the specified format. See strftime for format syntax details.
.BR

.PP
.SS
.B [Clock] toString

 Returns a string describing the date and time
 represented by the clock object.
.BR

.PP
.SS
.B [Clock] add: [Number].

 Adds the number to the clock, updating its time accordingly.
 Note that this is typically used with a qualifier.
 If the qualifier is 'hours' the number is treated as hours and
 the specified number of hours will be added to the time.

 The Clock object understands the following qualifiers
 if the selected language is English:

 sec, second, seconds,
 min, minute, minutes,
 hrs, hour, hours,
 day, days,
 week, weeks,
 month, months,
 year, years

 Note that it does not matter which form you use, 2 hour means
 the same as 2 hours (plural).

 Usage:

 clock add: 3 minutes. #adds 3 minutes
 clock add: 1 hour.    #adds 1 hour
 clock add: 2 second.  #adds 2 seconds
.BR

.PP
.SS
.B [Clock] subtract: [Number].

 Same as '[Clock] add:' but subtracts the number instead of adding it to
 the clock's time.
.BR

.PP
.SS
.B [Clock] new

 Creates a new clock, by default a clock will be set to
 the UTC timezone having the current time.
.BR

.PP
.SS
.B [Clock] processorClock

 returns the number of processor ticks since the beginning of this program.
 Note that this will be reset depending on the processor
.BR

.PP
.SS
.B [Clock] ticksPerSecond

 returns the count of processor ticks in a second
.BR

.PP
.SS
.B [Clock] timeExecutionOf: [Block]

 How long does the execution of the block take? (returns in cpu ticks)
.BR

.PP
.SS
.B [Clock] executionSeconds: [Block]

 How long does the execution of the block take? (returns in seconds)
.BR

.PP
.SS
.SH
 Pen
.B _OBJ_DEF Pen
.BR

.PP
.SS
.B [Pen] write: [String]

 Writes string to console.
.BR

.PP
.SS
.B [Pen] writeln: [String]

 Writes string to console, with a newline at the end.
.BR

.PP
.SS
.B [Pen] brk

 Outputs a newline character.
.BR

.PP
.SS
.SH
 Thread
.B _OBJ_DEF Thread
.BR

.PP
.SS
.B [Thread] new

 creates a new thread (no target)
.BR

.PP
.SS
.B [Thread] target: [Block]

 set the target of the thread instance
.BR

.PP
.SS
.B [Thread] args: [Block]

 set the args of the thread instance
.BR

.PP
.SS
.B [Thread] new: [Block] [args: [Array]]

 create a new thread with a target and optionally some arguments
.BR

.PP
.SS
.B [Thread] run

 runs the thread
.BR

.PP
.SS
.B [Thread] join

 joins the thread
.BR

.PP
.SS
.B [Thread] id

 returns the thread ID
.BR

.PP
.SS
.B [Thread] name [: [String]]

 returns the name of a thread (or alternatively sets it)
.BR

.PP
.SS
.SH
 Reflect
.B _OBJ_DEF Reflect
.BR

.PP
.SS
.B Reflect addGlobalVariable: [name:String]

 adds a variable named <name> to the global context
.BR

.PP
.SS
.B Reflect addLocalVariable: [name:String]

 adds a variable named <name> to the Local context
.BR

.PP
.SS
.B Reflect addPrivateVariable: [name:String]

 adds a variable named <name> to this context
.BR

.PP
.SS
.B Reflect set: [name:String] to: [Object]

 dynamically sets a binding
.BR

.PP
.SS
.B Reflect getContext

 returns all the context keys
.BR

.PP
.SS
.B Reflect getMethodsOf: [Object]

 returns all the method names of object
.BR

.PP
.SS
.B Reflect getPropertiesOf: [Object]

 returns all the property names of object
.BR

.PP
.SS
.B [Reflect] getObject: [s:String]

 looks for the object `s` in the current context or any of the contexts beneath
.BR

.PP
.SS
.B [Reflect] objectExists: [Object]

 returns whether the object exists
.BR

.PP
.SS
.B [Reflect] addArgumentTo: [Block] named: [s:String]

 adds a new argument `s` to the block
.BR

.PP
.SS
.B [Reflect] copyBlock: [b:Block]

 copies block b to a new context
.BR

.PP
.SS
.B [Reflect] newSharedObject

 makes a memmapped object. (Automatic destructor exists)
.BR

.PP
.SS
.B [Reflect] link: [o:Object] to: [p:Object]

 casts o to object type p
.BR

.PP
.SS
.B [Reflect] objectExists: [o:String]

 checks whether the object named o exists
.BR

.PP
.SS
.B [Reflect] isObject: [o:Object] linkedTo: [p:Object]

 checks whether p is anywhere in o's link chain
.BR

.PP
.SS
.B [Reflect] isObject: [o:Object] childOf: [p:Object]

 returns whether p is the parent of o
.BR

.PP
.SS
.B [Reflect] generateLinkTree: [o:Object]

 generates a linear tree, representing the chain of inheritance for object o
.BR

.PP
.SS
.B [Reflect] primitiveLinkOf: [o:Object]

 gets the first primitive object associated with o in its link chain
.BR

.PP
.SS
.B [Reflect] typeOf: [Object]

 returns a type constructor suited for the object
.BR

.PP
.SS
.B [Reflect] isObject: [Object] constructibleBy: [Object]

 checks if the first object can be made from the second object (Constructor)
.BR

.PP
.SS
.B [Reflect] parentOf: [o:Object]

 gets the first immediate parent of o.
.BR

.PP
.SS
.B [Reflect] getResponder: [r:String] ofObject: [o:Object]

 gets the method r from object o, AS IS
 The returned block will not contain any references to o.
 So a context must be supplied. (Takes a 'self' argument first)
.BR

.PP
.SS
.B [Reflect] run: [Block] forObject: [object:Object] arguments: [Array]

 runs a block with its 'me'/'my' set to object
.BR

.PP
.SS
.B [Reflect] run: [Block] inContext: [Map] arguments: [Array]
.BR

.PP
.SS
.B [Reflect] runHere: [Block] forObject: [o:Object] arguments: [Array]

 runs a block with its 'me'/'my' set to object, without switching contexts
.BR

.PP
.SS
.B [Reflect] closure: [String] of: [Object]

 captures a method from an object as a closure

 (Reflect closure: 'closure:of:' of: Reflect) applyTo: 'toString' and: 10. #'10'
.BR

.PP
.SS
.B [Reflect] getProperty: [p:String] ofObject: [o:Object]

 returns the property p of object o.
 this will produce an error should said property not exist.

 Reflect getProperty: 'end' ofObject: Eval
.BR

.PP
.SS
.B [Reflect] disableInstrumentation
 Sends a message to an object with some arguments bypassing the instrumentor
.BR

.PP
.SS
.B [Reflect] enableInstrumentation
 Sends a message to an object with some arguments bypassing the instrumentor
.BR

.PP
.SS
.B [Reflect] registerInstrumentor: [Block<object, message, arguments>:<object, message, arguments>] forObject: [Object]

 register to an event that fires every time a message is sent for an specific object.
 This instrumentor will have to handle all message sending operations
 using `[Reflect] disableInstrumentation` and '[Reflect] enableInstrumentation'.
 return value is used as the result of the message, unless it is the instrumentor function,
 In which case, the message is handed down to the object raw
.BR

.PP
.SS
.B [Reflect] unregisterInstrumetationForObject: [Object]

 Unregister the instrumentation block for the given object
.BR

.PP
.SS
.B [Reflect] currentInstrumentorFor: [Object]

 gets the current instrumentor instance, or Nil if none exists
.BR

.PP
.SS
.B @Experimental

 [Reflect] runAtGlobal: [Block] arguments: [[Object]]

 Runs a block at global context passing it the arguments
.BR

.PP
.SS
.B [Reflect] runInNewContext: [Block]

 runs a block in a new context and returns that context
.BR

.PP
.SS
.B [Reflect] thisContext

 returns the current context as a map
.BR

.PP
.SS
.B [Object] setPrivate: [String] value: [Object]

 sets a private property of the object
.BR

.PP
.SS
.SH
 Fiber
.B _OBJ_DEF Fiber
.BR

.PP
.SS
.B Fiber new: [Block]

 Creates a new Fiber object that does (Block) upon control being yielded to it

 Fiber is a co-processing method in citron.
 Think software level threads
.BR

.PP
.SS
.B [Fiber] yield

 yield control from the current object
.BR

.PP
.SS
.B [Fiber] yield: [Object]

yield control and pass an object along
.BR

.PP
.SS
.B [Fiber] waitForAll

 Wait until all fibers return
.BR

.PP
.SS
.B [Fiber] waitFor:

 Wait until fiber returns
.BR

.PP
.SS
.B [Fiber] yielded

 get the object that the last fiber yielded, or Nil if no object was yielded
.BR

.PP
.SS
.B [Fiber] unpack: [String:Ref]
 Assigns the fiber instance to the reference
 (Always prefer using algebraic deconstruction assignments: look at section 'Assignment')
.BR

.PP
.SS

.SH BUGS
This is a preliminary version (< 1.0) of Citron, there might still be very serious bugs.
Please refrain from using this version in a production environment. This version of Citron
is still considered 'alpha' stage and cannot be expected to be reliable.

.SH AUTHOR
AnotherTest and the Citron Community (Nil)
.PP
devanothertest@gmail.com

