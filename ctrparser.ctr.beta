var CtrParser is Object new.
var CtrLexer is Object new.
var CtrTokDesc is Map new.
var CtrTok is Map new.
var CtrTokRev is Map new.
Boolean on: 'neg' do: {
  ^(me either: False or: True).
}.
CtrTokDesc put: 'reference' at: 'ref',
       put: '\'' at: 'quote',
       put: 'number' at: 'number',
       put: '(' at: 'paropen',
       put: ')' at: 'parclose',
       put: '{' at: 'blockopen',
       put: '}' at: 'blockclose',
       put: ':' at: 'colon',
       put: '.' at: 'dot',
       put: ',' at: 'chain',
       put: 'True' at: 'booleanyes',
       put: 'False' at: 'booleanno',
       put: 'Nil' at: 'nil',
       put: 'is' at: 'assignment',
       put: '^' at: 'ret',
       put: '↑' at: 'ret_unicode',
       put: 'end of program' at: 'fin',
       put: '(unknown token)' at: 'unknown'.

CtrTok put: 'ret' at: 0,
       put: 'assignment' at: 1,
       put: 'blockclose' at: 2,
       put: 'blockopen' at: 3,
       put: 'booleanno' at: 4,
       put: 'booleanyes' at: 5,
       put: 'chain' at: 6,
       put: 'colon' at: 7,
       put: 'dot' at: 8,
       put: 'fin' at: 9,
       put: 'nil' at: 10,
       put: 'number' at: 11,
       put: 'parclose' at: 12,
       put: 'paropen' at: 13,
       put: 'quote' at: 14,
       put: 'ret' at: 15.
CtrTok each: { :k :v CtrTokRev put: k at: v. }.
Pen write: 'Init'.
CtrLexer on: 'init' do: {
  my lineno is 0.
  my oldlineno is 0.
  my charpos is 0.
  my code is ''.
  my buffer is ''.
  my tokenVLen is 0.
  my codeEOI is ''.
  my oldpos is 0.
  my olderpos is 0.
  my verbatim is False.
  my stringInterpolation is 0.
  my ivarname is ''.
  my verbatimInsertQuote is 0.
}.

CtrLexer on: 'isDelimiter:' do: { :c
  ^(c containsPattern: '\\(|\\)|\\{|\\}|,|\\.|\\:|\\s').
}.
CtrLexer on: 'isspace:' do: { :c var meh is (c containsPattern: '\\s'). ^meh. }.
CtrLexer on: 'isdigit:' do: { :c ^(c containsPattern: '\\d').}.
CtrLexer on: 'emitError:' do: { :msg
  var lineno is my lineno.
  var ms is '$$msg on line: $$lineno'.
  thisBlock error: ms.
}.

CtrLexer on: 'load:' do: { :prg
  my code is prg.
  my buffer is ''.
  my lineno is 0.
}.

CtrLexer on: 'tokenValue' do: { ^my buffer. }.
CtrLexer on: 'tokenDescribe:' do: { :tok
  var description is CtrTokDesc @ tok.
  (description isNil) ifTrue: {description is CtrTokDesc @ 'unknown'.}.
  ^description.
}.
CtrLexer on: 'tokenValueLength' do: { ^my tokenVLen. }.
CtrLexer on: 'putBack' do: {
  (my stringInterpolation > 0) ifTrue: { my stringInterpolation -=: 1. },
  ifFalse: {
    my charpos is my oldpos.
    my oldpos is my olderpos.
    my lineno is my oldlineno.
  }.
}.
CtrLexer on: 'checkNextLineEmpty' do: {
  var pattern is '^$'.
  var out is False.
  var code is my code.
  var charpos is my charpos.
  {
    out is (code from: charpos to: (code length)) containsPattern: pattern.
  } catch: { :err CtrLexer emitError: err. }, run.
  ^out.
}.

CtrLexer on: 'token' do: {
  var c is ''.
  var i is 0.
  var comment_mode is False.
  var presetToken is 0.
  my tokenVLen is 0.
  my olderpos is my oldpos.
  my oldpos is my charpos.
  my oldlineno is my lineno.
  (my stringInterpolation = 1) ifTrue: { presetToken is CtrTokRev @ 'quote'. }.
  (my stringInterpolation = 2) ifTrue: {
    my buffer append: '+'.
    my tokenVLen = 1.
    presetToken is CtrTokRev @ 'ref'.
  }.
  (my stringInterpolation = 3) ifTrue: { my beffer append: my ivarname. presetToken is CtrTokRev @ 'ref'. }.
  (my stringInterpolation = 4) ifTrue: {
    my buffer append: '+'.
    my tokenVLen = 1.
    presetToken is CtrTokRev @ 'ref'.
  }.
  (my stringInterpolation = 5) ifTrue: { my code is my codeEIO. presetToken is CtrTokRev @ 'quote'. }.
  (my stringInterpolation !=: 0) ifTrue: { my stringInterpolation +=: 1. thisBlock error: presetToken. }.
  (my verbatim & (my verbatimInsertQuote = my charpos)) ifTrue: {
    thisBlock error:  (CtrTokRev @ 'quote').
  }.
  (((my code at: my charpos) = '\n') & (me checkNextLineEmpty)) ifTrue: {
    my charpos +=: 1.
    thisBlock error: (CtrTokRev @ 'dot').
  }.
  c is (my code at: my charpos).
  #Pen write: '$$c ,'.
  { var end is (my charpos !=: (my code length - 1)). var e is ((CtrLexer isspace: c) | (c containsPattern: '\\#') | comment_mode). ^(e & end).} whileTrue: { #Pen write: c.
    #Pen write: my code, write: ' ', write: my charpos, brk.
    (c = '\n') ifTrue: { comment_mode is False. my lineno +=: 1. }.
    (c = '#') ifTrue: { comment_mode is True. }.
    my charpos +=: 1.
    c is (my code at: my charpos).
  }.
  #Pen write: '$$c ,'.
  (my charpos = (my code length - 1)) ifTrue: { thisBlock error: CtrTokRev @ 'fin'. }.
  (c = '(') ifTrue: { my charpos +=: 1. thisBlock error: CtrTokRev @ 'paropen'.}.
  (c = ')') ifTrue: { my charpos +=: 1. thisBlock error: CtrTokRev @ 'parclose'.}.
  (c = '{') ifTrue: { my charpos +=: 1. thisBlock error: CtrTokRev @ 'blockopen'.}.
  (c = '}') ifTrue: { my charpos +=: 1. thisBlock error: CtrTokRev @ 'blockclose'.}.
  (c = '.') ifTrue: { my charpos +=: 1. thisBlock error: CtrTokRev @ 'dot'.}.
  (c = ',') ifTrue: { my charpos +=: 1. thisBlock error: CtrTokRev @ 'chain'.}.
  (c = 'i' & ((my code at: (my charpos + 1)) = 's') & (CtrLexer isspace: (my code at: (my charpos + 2)))) ifTrue: {
    my charpos +=: 2.
    thisBlock error: CtrTokRev @ 'assignment'.
  }.
  (c = ':') ifTrue: { my charpos +=: 1. thisBlock error: CtrTokRev @ 'colon'.}.
  (c = '^') ifTrue: { my charpos +=: 1. thisBlock error: CtrTokRev @ 'ret'.}.
  (c = '↑') ifTrue: { my charpos +=: 1. thisBlock error: CtrTokRev @ 'ret'.}.
  (c = '\'') ifTrue: { my charpos +=: 1. thisBlock error: CtrTokRev @ 'quote'.}.
  (((c = '-') & (CtrLexer isdigit: ((my code at: (my charpos + 1))))) | (CtrLexer isdigit: c)) ifTrue: {
    my buffer append: c. my tokenVLen +=: 1. my charpos +=: 1.
    c is (my code at: my charpos).
    { ^ (CtrLexer isdigit: c). } whileTrue: { #Pen write: c.
      my buffer append: c. my tokenVLen +=: 1. my charpos +=: 1.
      c is (my code at: my charpos).
    }.
    (c = '.') ifTrue: {
      (CtrLexer isdigit: (my code at: (my charpos + 1))) ifFalse: {thisBlock error: CtrTokRev @ 'number'.}.
      my buffer append: c. my tokenVLen +=: 1. my charpos +=: 1.
      c is (my code at: my charpos).
    }.
    {^ (CtrLexer isdigit: c). } whileTrue: { #Pen write: c.
      my buffer append: c. my tokenVLen +=: 1. my charpos +=: 1.
      c is (my code at: my charpos).
    }.
    thisBlock error: CtrTokRev @ 'number'.
  }.
  ((my code from: my charpos to: (my charpos + 4)) = 'True') ifTrue: {
    (CtrLexer isDelimiter: (my code at: (my charpos + 4))) ifTrue: {
      my charpos +=: 4.
      thisBlock error: CtrTokRev @ 'booleanyes'.
    }.
  }.
  (my code from: my charpos to: (my charpos + 5) = 'False') ifTrue: {
    (CtrLexer isDelimiter: (my code at: (my charpos + 5))) ifTrue: {
      my charpos +=: 5.
      thisBlock error: CtrTokRev @ 'booleanno'.
    }.
  }.
  (my code from: my charpos to: (my charpos + 3) = 'Nil') ifTrue: {
    (CtrLexer isDelimiter: (my code at: (my charpos + 3))) ifTrue: {
      my charpos +=: 3.
      thisBlock error: CtrTokRev @ 'nil'.
    }.
  }.
  (my code from: my charpos to: (my charpos + 2) = '?>') ifTrue: {
    my verbatim is True.
    my charpos +=: 1.
    my buffer append: '?'.
    my tokenVLen is 1.
    thisBlock error: CtrTokRev @ 'ref'.
  }.
  (my code from: my charpos to: (my charpos + 1) = '>' & my verbatim) ifTrue: {
    my verbatimInsertQuote is my charpos + 1.
    my charpos +=: 1.
    my buffer append: '>'.
    my tokenVLen is 1.
    thisBlock error: CtrTokRev @ 'ref'.
  }.
  { ^((CtrLexer isspace: c) neg) & ((c !=: '#') & (c !=: '(') & (c !=: ')') & (c !=: '{') & (c !=: '}') & (c !=: '.') & (c !=: ',') & (c !=: '^') & (c !=: ':') & (c !=: '\'') & (my charpos !=: (my code length))).} whileTrue: { #Pen write: c.
    #Pen write: '$$c ,'.
    my buffer append: c. my tokenVLen +=: 1. my charpos +=: 1. c is my code at: my charpos.
  }.
  thisBlock error: CtrTokRev @ 'ref'.
}.

CtrLexer on: 'readStr' do: {
  var strbuf is ''.
  var c is ''.
  var memblock is 1.
  var escape is 0.
  var beginbuff is ''.
  var page is 100.
  (my stringInterpolation = 6) ifTrue: {
    my ivarname is ''.
    my stringInterpolation = 0.
  }.
  my tokenVLen is 0.
  c is my code at: my charpos.
  beginbuff is strbuf.
  { ^(((my verbatim neg) & ((c !=: '\'') | escape = 1)) | ((my verbatim) & (((c = '<') & (my charpos + 1 < (my code length - 1)) & (my code at: (my charpos + 1) = '?')) neg) & (my charpos < my code length - 1))). } whileTrue: {# Pen write: c.
    ((my verbatim neg) & (escape = 0) & (c = '$') & (my code at: (my charpos + 1) = '$')) ifTrue: {
      var q = 2.
      { var cq is my code at: (my charpos + q). ^(((my charpos + q) < (my code length - 1)) & (((CtrLexer isspace:cq) neg) & (cq !=: '$') & (cq !=: '\'') & (q < 255))).} whileTrue: { q +=: 1.}.
      var cq is my code at: (my charpos + q).
      ((CtrLexer isspace: cq) | (cq = '$') | (cq = '\'') ) ifTrue: {
        my ivarname is my code from: (my charpos + 2) to: (my charpos + q - 2 ).
        my stringInterpolation is 1.
        my codeEOI is my charpos + q + 0.
      }, break.
    }.
    (c = '\n') ifTrue: { my lineno +=: 1.}.
    (escape = 1) ifTrue: {
      var c0 is c from:0 to:1.
      (c0 = 'n') ifTrue: {c is '\n'.}.
      (c0 = 'r') ifTrue: {c is '\r'.}.
      (c0 = 't') ifTrue: {c is '\t'.}.
      (c0 = 'v') ifTrue: {c is '\v'.}.
      (c0 = 'b') ifTrue: {c is '\b'.}.
      (c0 = 'a') ifTrue: {c is '\a'.}.
      (c0 = 'f') ifTrue: {c is '\f'.}.
    }.
    (c = '\\' & escape = 0 & my verbatim) ifTrue: {
      escape is 1.
      my charpos +=: 1.
      c is my code at: my charpos.
    }.
    my tokenVLen +=: 1.
    escape is 0.
    strbuf append: c.
    my charpos +=: 1.
    c is my code at: my charpos.
  }.
  (my verbatim) ifTrue: {
    (my charpos >=: (my code length - 1)) ifTrue: {
      my code append: '<?.'.
    }.
  }.
  my verbatim is False.
  my verbatimInsertQuote is 0.
  ^strbuf.
}.


CtrLexer init.
CtrLexer load: 'Pen write: test.'.
{CtrLexer token.} catch: {:e Pen write: e, brk.}, run.
{CtrLexer token.} catch: {:e Pen write: e, brk.}, run.
{CtrLexer token.} catch: {:e Pen write: e, brk.}, run.
{CtrLexer token.} catch: {:e Pen write: e, brk.}, run.
{CtrLexer token.} catch: {:e Pen write: e, brk.}, run.
{CtrLexer token.} catch: {:e Pen write: e, brk.}, run.
