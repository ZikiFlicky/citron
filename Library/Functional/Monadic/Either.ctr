var Either is Monad new
  on: 'left:' do: {:p
    ^Left cnew: {
      my value is p.
    }.
  },
  on: 'right:' do: {:p
    ^Right cnew: {
      my value is p.
    }.
  },
  on: 'unpack:' do: {:to
    var self is me.
    ^((me type) = (to type))
      either: {^{
        ^const self unwrap unpack: (const to unwrap).
      }.}
      or: {
          thisBlock error: ('%s cannot be constructed by %s' % [(Reflect strTypeOf: to), (Reflect strTypeOf: const self)]).
      }.
  },
  on: 'equals:' do: {:other
    var self is me.
    ^(me type) = (var tt is other type)
      either: {
        ^(self unwrap) = (other unwrap).
        }
      or: False.
  },
  on: 'isLeft' do: {
    ^(me type) = (Left type).
  },
  on: 'bind:' do: {:fn
    var thisContext is me.
    var value is my value.
    var self is me.
    var val is fn applyTo: value.
    (Reflect isObject: val linkedTo: Either) ifFalse: {
      ((var vt is val type) = (value type)) | (value type equals: Nil type) ifTrue: {
        val is self $ val.
      }, else: {
        thisBlock error: ('Invalid return type for Either#bind:, Expected %s|%s, got %s' % [(Either type), (value type), (val type)]).
      }.
    }.
    ^val.
  },
  learn: '=' means: 'equals:',
  on: 'type' do: {\ 'Either' }.

var Left is Either cnew: { value => Nil. },
  on: '$' do: {:v
    ^me cnew: {
      my value is v.
    }.
  },
  on: 'type' do: {
    ^'Either#Left#%s' % [(my value type)].
  },
  on: 'toString' do: {\
    'Left $ (%s)' % [my value].
  },
  on: 'unwrap' do: {\ my value }.
var Right is Either new
  on: '$' do: {:v
    ^me cnew: {
      my value is v.
    }.
  },
  on: 'type' do: {
      ^'Either#Right#%s' % [(my value type)].
  },
  on: 'toString' do: {\ 'Right $ (%s)' % [my value] },
  on: 'unwrap' do: {\ my value }.
import
  export: Right as: 'Right',
  export: Left as: 'Left',
  export: Either as: 'Either'.
