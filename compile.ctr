#!/usr/bin/env ctr

Broom memoryLimit: 1024 * 1024 * 512.

(Program argCount = 2) ifTrue: {
  Pen writeln: 'Usage: compile <infile> [<outfile> (defaults to a.out)] [--keep-intermediates] [--import-intrinsic] [-- <compiler options>]'.
  Program exit.
}.

var prgargs is Array new fill: Program argCount - 2 with: \:i Program argument: i + 2.
prgargs on: 'shiftArg' do: {:self ^self count > 0 either: { ^self shift. } or: Nil. }.

import Library/Data/SwitchCase.
import Library/Data/IO/Pen: 'pPen'.
import Library/Data/Map.
import Library/AST/ast2ctrcode: 'ast2ctrcode'.

var errPen is pPen for: (File special: 'stderr').

#:language XFrozen

Array on: 'toBoolean' do: { ^me count > 0. }.

var import_intrinsic is False.
var optimize is False.

var var_id is 0.
var gvar_id is 0.
var fun_id is 0.
# [type_s, name, value_s]
var variables is Array new.
var global_variables is Array new.

Array on: 'has_variable:' do: {:v
  ^any: \:x v = x @ 1.
}.

# name -> code
var functions is Map new.

var generate_single_arg_t is {:arg
  ^['ctr_object*', 'arg_v$$var_id', arg].
}.
var generate_single_argn_t is {:*args
  ^['ctr_argument', 'arg_vp$$var_id', (Map new put: args @ 0 at: '.object', put: args @ 1 at: '.next')].
}.

var c_addrof is \:x '&$$x'.

var generate_args is {:count:args
  ^Array new fill: count with: {:x
    var_id +=: 1.
    var argv is generate_single_arg_t[compile[(args at: x)]].
    variables push: argv.
    ^argv @ 1.
  }, reverse foldl: {:acc:x
    var_id +=: 1.
    var argvp is generate_single_argn_t[x, acc].
    variables push: argvp.
    ^c_addrof[argvp @ 1].
  } accumulator: 'NULL'.
}.

var return_now is False.

var strmap is Map new.

String on: 'literalEscape' do: {
  ^(me ~ ?>s/\\/\\\\/g<?) escapeDoubleQuotes ~ 's/\n|\r|\t|\v|\a|\b|\f/\\\\n/g'.
}.

var make_or_get_str is {:s
  s is s literalEscape.
  s length = 0 ifTrue: { errPen yellow writeln: 'NULL creation requested in context $$current_context (after %s)' % [last_context], resetColor. ^'ctr_build_string("", 1)'. }.
  ^strmap at: s, or: {
    gvar_id +=: 1.
    var name is 'ctr_str_$$gvar_id'.
    # errPen writeln: '%s = %s' % [name, s].
    global_variables push: ['ctr_object*', name, 'ctr_build_string("%s", %d)' % [s, s length]].
    strmap put: name at: s.
    ^name.
  }.
}.

var generate_func_param_load is {:ps
  var params is Array new fill: ps count with: {:i ^ps at: i, value. }.
  var x is make_or_get_str['me'].
  var s is 'if(!ctr_find_(%s, 1)) ctr_assign_value_to_local_by_ref(%s, a_);\n' % [x, x].
  params each_v: {:param
    s +=: 'ctr_assign_value_to_local_by_ref(%s, b__->object);\nb__ = b__->next;\n' % [make_or_get_str[param]].
  }.
  ^s.
}.

var current_context is Nil.
var last_context is Nil.

var imported_files is Array new.

var compile_subprogram is {:*subs
  # Emits an inner block
  subs is subs fmap: (\:x x type = 'UNAMESSAGE' either: x or: {
    var xv is x value.
    ['__map2Array:', 'searchPaths', 'export:as:', 'require-parent', 'dir:',
     '__resolve_request:internally:', 'return:', 'return', '__realloc:', '__load:',
     '__unify:', 'respondTo:', 'respondTo:and:'
    ] contains: xv, continue.
    errPen red writeln: 'named imports are not supported yet(%s), No symbols will be imported' % [xv], resetColor.
    var vals is xv split: ':'.
    ^vals fmap: \:a ($(import something) @ 1) value: a.
  }), foldl: (\:acc:x x isA: Array, either: {^acc + (x fmap: \:x [True, x]).} or: acc + [[False, x]]) accumulator: [].
  var last_context_c is last_context.
  last_context is current_context.
  current_context is $(import).
  var curdir is File new: '.', realPath.
  var parts is Array new.
  var paths is subs fmap: ({:sub
    var x is sub head either: {
      sub is sub last value.
      var res is import __resolve_request: sub internally: True.
      res any: \:x x isNil, ifTrue: { thisBlock error: 'Unknown import $$sub'. }.
      ^[sub, res].
    } or: {
      sub is sub last value.
      var res is import __resolve_request: sub internally: True.
      res any: \:x x isNil, ifTrue: { thisBlock error: 'Unknown import $$sub'. }.
      Pen writeln: 'Switching to dir ' + (res @ 1).
      Program changeDirectory: res @ 1.
      ^[sub, res].
    }.
    var f is x @ 1 @ 0.
    imported_files contains: f, continue.
    imported_files push: f.
    var resv is x @ 1.
    var name is x @ 0.
    resv any: \:x x isNil, ifTrue: {
      thisBlock error: 'Could not find any import %s' % [name].
      True continue.
    }.
    var s is '/* import $$name */\n'.
    var oldvs is variables.
    var oldvarid is var_id.
    variables is Array new.

    s +=: compile[(AST parse: resv last read)].

    variables is oldvs.
    var_id is oldvarid.

    parts push: s.
  }).
  Program changeDirectory: curdir.

  current_context is last_context.
  last_context is last_context_c.
  ^parts fmap: \:x '{ $$x }', join: '\n'.
}.

var compile is {:ast
  last_context is current_context.
  current_context is ast.
  ^(frozen __ is
    case: 'LTRNUM' do: {
      ^'ctr_build_number_from_float(%d)' % [ast evaluate].
    },
    case: 'LTRSTRING' do: {
      var value is ast value.
      ^make_or_get_str[value].
    },
    case: 'LTRNIL' do: {
      ^'CtrStdNil'.
    },
    case: 'LTRBOOLTRUE' do: {
      ^'ctr_build_bool(1)'.
    },
    case: 'LTRBOOLFALSE' do: {
      ^'ctr_build_bool(0)'.
    },
    case: 'REFERENCE' do: {
      var value is ast value.
      #^'(ctr_find_(%s, 1) ?: CtrStdNil)' % [make_or_get_str[value]].
      ^'ctr_find_(%s, 0)' % [make_or_get_str[value]].
    },
    case: 'EXPRMESSAGE' do: {
      var rec is ast at: 0.
      (rec type = 'REFERENCE') & (rec value = 'import') ifTrue: {
        import_intrinsic ifTrue: {
          # Treat import as a compiler intrinsic
          ^compile_subprogram[(ast at: i),, (Generator from: 1 to: ast count - 1)].
        }.
        ^'ctr_string_eval(%s, NULL)' % [make_or_get_str[ast2ctrcode[ast]]].
      }.
      var all is Array new fill: ast count with: {:i ^compile[(ast at: i)]. }.
      var obj is all head.
      var msgs is all tail.
      ^msgs foldl: (\:acc:x 'ctr_send_message(%s, %s)' % [acc, x]) accumulator: obj.
    },
    case: 'UNAMESSAGE' do: {
      var value is ast value.
      ^'"%s", %d, NULL' % [value, value length].
    },
    case: 'BINMESSAGE' do: {
      var value is ast value.
      ^'"%s", %d, %s' % [value, value length, generate_args[1, ast]].
    },
    case: 'KWMESSAGE' do: {
      var value is ast value.
      ^'"%s", %d, %s' % [value, value length, generate_args[ast count, ast]].
    },
    case: 'EXPRASSIGNMENT' do: {
      var ref is ast at: 0.
      var _value is ast at: 1.
      ^(frozen __ is
        case: 0 do: {
          ^'ctr_assign_value(%s, %s)' % [make_or_get_str[ref value], (compile[_value])].
        },
        case: 1 do: {
          ^'ctr_assign_value_to_my(%s, %s)' % [make_or_get_str[ref value], (compile[_value])].
        },
        case: 2 do: {
          ^'ctr_assign_value_to_local(%s, %s)' % [make_or_get_str[ref value], (compile[_value])].
        },
        case: 3 do: {
          ^'ctr_assign_value(%s, %s)' % [make_or_get_str[ref value], (compile[_value])].
        },
        case: 4 do: {
          thisBlock error: 'modifier 4 not supported in assignments'.
          ^'ctr_assign_value'.
        },
        case: 5 do: {
          thisBlock error: 'modifier 5 not supported in assignments'.
          ^'ctr_assign_value'.
        },
        default: {
          ^'ctr_assign_value(%s, %s)' % [make_or_get_str[ref value], (compile[_value])].
        }) switch: ref modifier.
    },
    case: 'SYMBOL' do: {
      var value is ast value.
      ^'ctr_get_or_create_symbol_table_entry("%s", %d)' % [value, value length].
    },
    case: 'NESTED' do: {
      ^compile[(ast at: 0)].
    },
    case: 'CODEBLOCK' do: {
      var oldvs is variables.
      var oldvarid is var_id.
      var instrs is ast at: 1.
      fun_id +=: 1.
      var funname is 'ctr_function_$$fun_id'.
      variables is Array new.
      var_id is 0.
      var funcode is '  ctr_object* result = (%:L);\n' % [', ', ((Array new fill: instrs count with: {:x ^compile[instrs @ x].}) or: ['NULL'])].
      funcode is generate_func_param_load[ast @ 0] + '\n' + generate_inits['  '] + funcode + 'return result;\n'.
      variables is oldvs.
      var_id is oldvarid.
      functions put: funcode at: funname.
      ^'internal_ctr_create_block__(%s)' % [funname].
    },
    case: 'PROGRAM' do: {
      var instrs is ast.
      var res is Array new fill: instrs count with: {:x
        variables is Array new.
        var s is compile[instrs @ x].
        var i_s is generate_inits['  '].
        ^i_s + s + ';\n'.
      }.
      ^res join: ''.
    },
    case: 'ENDOFPROGRAM' do: { ^'CtrStdNil'. },
    case: 'RETURNFROMBLOCK' do: { return_now is True. ^compile[ast @ 0]. },
    case: 'IMMUTABLE' do: {
      var elements is ast at: 0.
      var count is elements count.
      var_id +=: 1.
      var vname is 'ctr_tuple_$$var_id'.
      var props is Map new
        put: 'ctr_internal_create_object(CTR_OBJECT_TYPE_OTARRAY)' at: '', # initialize
        put: 'ctr_heap_allocate(sizeof (ctr_collection))' at: '->value.avalue',
        put: 'ctr_heap_allocate(sizeof (ctr_object *) * %d)' % [count] at: '->value.avalue->elements',
        put: count at: '->value.avalue->head',
        put: 0 at: '->value.avalue->tail',
        put: count at: '->value.avalue->length',
        put: 1 at: '->value.avalue->immutable'.
      var mp is Map new.
      Array new fill: count with: \:x compile[elements @ x], each: {:i:x
        props put: x at: '->value.avalue->elements[%d]' % [i].
      }.
      props each: {:k:v mp put: v at: k.}.
      variables push: ['ctr_object*', vname, mp].
      ^vname.
    },
    default: { errPen red writeln: '$$ast is not compilable at the moment', resetColor. }) switch: ast type.
}.

var single_argn_t is {:value
  var_id +=: 1.
  var argt is generate_single_arg_t[value].
  var_id +=: 1.
  var argnt is generate_single_argn_t[argt @ 1, 'NULL'].
  variables push: argt, push: argnt.
  ^c_addrof[argnt @ 1].
}.

var generate_inits is {:q
  var src is ''.
  variables each_v: {:v
    (v last isA: Map) either: {
      var vn is v @ 1.
      src +=: '%s %s;\n' % [v @ 0, vn].
      var vv is v @ 2.
      vv each: {:k:v
        src +=: '%s%s = %s;\n' % [vn, k, v].
      }.
    } or: {
      src +=: '%s%s %s = %s;\n' % ([q] + v).
    }.
  }.
  ^src.
}.

var generate_funcs is {
  var s is ''.
  var init is ''.
  functions each: {:k:v
    init +=: 'ctr_object* %s(ctr_object*a_, ctr_argument*b__);\n' % [k].
    s +=: 'ctr_object* %s(ctr_object*a_, ctr_argument*b__) {\n%s }\n' % [k, v].
  }.
  ^init + s.
}.

var generate_globals is {
  var decl is ''.
  var sv is ''.
  global_variables each_v: {:v
    decl +=: '%s %s;\n' % v init.
    (v last isA: Map) either: {
      var vn is v @ 1.
      var vv is v @ 2.
      vv each: {:k:v
        sv +=: '%s%s = %s;\n' % [vn, k, v].
      }.
    } or: {
      sv +=: '%s = %s;\n' % v tail.
    }.
  }.
  ^[decl, sv].
}.

var compile_complete is {:ast
  var s is compile[ast].
  var gl is generate_globals[].
  ^ '#include <Citron/citron.h>\n'
  + 'ctr_object* internal_ctr_create_block__(ctr_object*(fn(ctr_object*,ctr_argument*))) {\n'
  + '  ctr_object* obj = ctr_internal_create_object(CTR_OBJECT_TYPE_OTNATFUNC);\n'
  + '  obj->value.fvalue = fn;\n'
  + '  ctr_set_link_all(obj, CtrStdBlock);\n'
  + '  return obj;\n}\n'
  + (gl @ 0)
  + generate_funcs[]
  + 'int main() {\n'
  + '  ctr_initialize_ex();\n'
  + (gl @ 1)
  # + generate_inits['  ']
  + s + ';\n'
  + '  if (CtrStdFlow) {\n'
  + '    ctr_object* err = CtrStdFlow; CtrStdFlow = NULL;\n'
  + '    ctr_send_message_variadic(CtrStdConsole, "writeln:", 8, 1, err);\n'
  + '    exit(1);\n}\n'
  + '  return 0;\n}'.
}.

var filename is prgargs shift.

filename = '-h' ifTrue: {
  Pen green writeln: 'Citron down-compiler'.
  Pen tab yellow writeln: '[WARNING] Incomplete software'.
  Pen resetColor writeln: 'Usage: compile <infile> [<outfile> (defaults to a.out)] [--keep-intermediates] [--import-intrinsic] [-- <compiler options>]'.

  Program exit.
}.

var ofilename is prgargs shiftArg or: 'a.out'.
var src is File new: filename, read.
var tgt is File new: ofilename + '.c'.

import_intrinsic is prgargs contains: '--import-intrinsic'.
optimize is prgargs contains: '-O'.

import_intrinsic ifTrue: { errPen magenta writeln: '--import-intrinsic is unstable and will probably not work correctly', resetColor. }.

errPen write: 'Compiling file $$filename into $$ofilename ...\n'.

var idx is prgargs indexOf: '--'.
var comp_opts is optimize either: ['-Ofast', '-ftree-vectorize', '-fomit-frame-pointer'] or: [].
idx > -1 ifTrue: {
  comp_opts is prgargs from: idx - 1 lengthMax: prgargs count.
  errPen green writeln: 'Will pass %:L to the compiler' % [' ', comp_opts], resetColor.
}.

tgt write: compile_complete[(AST parse: src)].
Shell gcc: '%s %:L -ggdb3 -lcitron -o %s' % [tgt path, '\x20', comp_opts, ofilename].
prgargs contains: '--keep-intermediates', ifTrue: { Program exit. }.
tgt delete.
