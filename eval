#!/usr/bin/env ctr
#
Broom autoAlloc: True. #Allow the memory to go sky-high
contextPurity is False. #This is not a pure context, since objects are mutated in-between evaluations. so disallowing purely functional things.
#Pen write: 'Extensions: ' + (File extensionsPath), brk.
File new: (File extensionsPath) + '/extensions/fileutils.ctr', include.

inp is ''.

ImportLib Queue.
ImportLib LRArray.

Eval is Object new.
Eval on: 'init' do: {
  my end is False.
  my color is 'resetColor'.
  my prompt is '>>> '.
  my args is Array new.
  my allowedColors is ('red blue magenta cyan yellow green resetColor' split: ' ') join: '|'.
  my evalQueue is Queue new.
  my globalvars is False.
  my history is LRArray new init: 100.
  my commands is Nil.
  my continuation is '...'.
  me genAccessors: 'equit'.
  me equit: False.
  me genReader: 'eServer'.
  my instr is False.
  ^me.
}.
Eval on: 'instrument' do: {my instr ifTrue: {Reflect enableInstrumentation.}.}.
Eval on: 'enableInstrumentation' do: {my instr is True.}.
Eval on: 'handleException:' do: {:e
  ^my equit either: {Pen red write: e, resetColor brk. ^e.} or: {thisBlock error: e.}.
}.
Eval on: 'end' do: { my end is True. me stopEvalServer. }.
Eval on: 'break' do: { my end ifTrue: {Broom sweep.}. ^my end. }.
Eval on: 'allowedColors' do: { ^my allowedColors. }.
Eval on: 'isAllowedColor:' do: { :c
  ^(c containsPattern: my allowedColors).
}.
Eval on: 'setColor:' do: { :c
  (me isAllowedColor: c) ifFalse: { thisBlock error: 'value $$c' + ' is not an allowed color.'. }.
  my color is c.
}.
Eval on: 'setPrompt:' do: { :p my prompt is p. }.
Eval on: 'setContinuation:' do: { :p my continuation is p. }.
Eval on: 'setArgs:' do: { :a my args := a. }.
Eval on: 'color' do: { ^my color. }.
Eval on: 'prompt' do: { ^my prompt. }.
Eval on: 'continuation' do: { ^my continuation. }.
Eval on: 'shiftArgs' do: { ^(my args shift). }.
Eval on: 'argCount' do: { ^(my args count). }.
Eval on: 'onlyRelevantArgs' do: { my args do shift shift done. }. #get rid of ./ctr eval

Eval on: 'startEvalServer' do: {
  var port is 5000 + (Dice rollWithSides: 1000).

  var EvalServer is Object new.
  EvalServer on: 'evaluate:' do: {:str
      ^str eval.
  }.

  my eServer is Program new: {:p
      p port: port.
      p serve: EvalServer.
  }.

  ^port.
}.

Eval on: 'startEvalServerOnPort:' do: {:port

  var EvalServer is Object new.
  EvalServer on: 'evaluate:' do: {:str
      ^str eval.
  }.

  my eServer is Program new: {:p
      p port: port.
      p serve: EvalServer.
  }.

  ^port.
}.

Eval on: 'stopEvalServer' do: {
  ^my eServer isNil not either: {my eServer signal: 1. ^True.} or: {^False.}.
}.

Eval on: 'Commands' do: {
  my commands is my commands or: {
    ^Map new
      put: {:args Eval end.} at: 'q',
      put: {:args ^Reflect strTypeOf: (args eval).} at: 't',
      put: {:args ^(args trim = '') either: {^Eval startEvalServer.} or: {^Eval startEvalServerOnPort: args eval.}.} at: 'server',
      put: {:args ^'Interpreter metacommands help:
      + q -- Quit
      + t <expression> -- type of expression
      + server [<port>] -- make an eval server on port <port>, or a random port.
      + !server -- kill the eval server
      + !m <expression> -- methods of the expression
      + !p <expression> -- properties of the expression
      + h -- show this help'.} at: 'h',
      put: {^Eval stopEvalServer.} at: '!server',
      put: {:args ^Reflect getPropertiesOf: (args eval).} at: '!p',
      put: {:args ^Reflect getMethodsOf: (args eval).} at: '!m'.
  }.
  ^my commands.
}.

Eval on: 'doMeta:' do: {:str:ptr
  var cmd is 'h'.
  var args is ''.
  str trim findPattern: '(\\W?\\w+)(\\s+(.*))?' do: {:parts cmd is parts @ 1. args is parts count > 2 either: {^parts @ 3.} or: ''.}.
  ^(Eval Commands at: cmd) applyTo: args.
}.

Eval on: 'evaluate:' do: { :str
  var eval_result_x is Nil.
  ^(str at: 0, = ':')
    either:
      ({ ^eval_result_x is Eval doMeta: (str skip: 1). } catch: {:e Eval handleException: e.})
    or:
      ({
          Eval instrument.
          ^(str startsWith: 'import') not
            either: ({
                ^Reflect runAtGlobal: {:str ^str eval.} arguments: str.
                } catch: {:e Eval handleException.}
            ) or: ({
                ^str eval.
                } catch: {:e Eval handleException.}).
        }).
}.
Eval on: 'evaluateFile:' do: { :fl
  {
    Pen yellow write: 'File ', magenta write: fl, yellow write: ' : Interpreting...', brk.
    File new: fl, include.
  } catch: { :e
      Eval handleException: e.
      # get rid of the trash.
      Broom sweep.
  }, run.
}.
Eval on: 'enqueue:' do: { :str
  my evalQueue enqueue: str.
}.
Eval on: 'queueHasItem' do: {
  ^(my evalQueue count !=: 0).
}.
Eval on: 'dequeue' do: { ^my evalQueue dequeue. }.
Eval on: 'pushHist:' do: {:h
  my history push: h.
}.
Eval on: 'executeLast:' do: {:n
  ^me evaluate: (my history @ n).
}.
Eval on: 'getHistory' do: {^my history.}.

Eval on: 'queryState:' do: {:query
    ^(((query countOf: '\'') - (query countOf: '\\\'')) even) & ((query countOf: '{') = (query countOf: '}')) & ((query countOf: '[') = (query countOf: ']')).
}.

Eval init.
Eval setArgs: (Array with: {:i ^Program argument: i. } count: (Program argCount)).
Eval onlyRelevantArgs.

#arguments that were not consumed
var args is Array new.

#global vars for evaler
var _  is Nil.
var __ is Nil.

Reflect registerInstrumentor: {:obj:msg:args
  Reflect disableInstrumentation.
  var ret is obj message: msg arguments: args.
  Pen green write: ('\n(%s : %s.%s(%s) => %s [%s]' formatObjects: [((var name is Reflect generateLinkTree: obj) join: '<-'), (name @ 0), msg, (args join: ', '), ret, (ret type)]), resetColor brk.
  Reflect enableInstrumentation.
  ^ret.
}.
Reflect disableInstrumentation.

# parse arguments
{ ^(Eval argCount > 0). } whileTrue: {
    # get an option
    var opt is Eval shiftArgs.
    args push: opt.
    # when passed -h, show help, then exit.
    opt case: '-h' do: {
        args pop. #consume option.
        Pen green write: 'Citron Evaluator.\n', resetColor.
        var P is Pen new.
        P on: 'indent:write:' do: {:i :w Pen write: (((Array < '  ') * i) join: ''). Pen write: w. }.
        P indent: 1 write: 'Eval mode help:', brk.
        P cyan indent: 1 write: 'Eval namespace', resetColor brk.
        P magenta indent: 2 write: '[Eval] setPrompt: [String] ', resetColor write: '-- Sets the prompt.', brk.
        P magenta indent: 2 write: '[Eval] setColor: [String] ', resetColor write: '-- sets the color of the output.', brk.
        P magenta indent: 2 write: '[Eval] getHistory ', resetColor write: '-- returns the 100 last commands.', brk.
        P magenta indent: 2 write: '[Eval] executeLast: [Number] ', resetColor write: '-- evaluates the Nth element of the history list.', brk.
        P magenta indent: 2 write: '[Eval] startEvalServer ', resetColor write: '-- starts an eval server in the background. returns the port.', brk.
        P magenta indent: 2 write: '[Eval] startEvalServerOnPort: [Number] ', resetColor write: '-- same as startEvalServer, with the port specified.', brk.
        P magenta indent: 2 write: '[Eval] end ', resetColor write: '-- Ends the eval.', brk.
        P indent: 1 write: 'Evaluates expressions in a single context.', brk.
        P indent: 1 write: 'Since all expressions are in single lines, pragma oneLineExpressions is active,', brk.
        P indent: 1 write: 'Hence ending expressions with a dot (.) is not required.', brk.
        P indent: 1 write: 'All the args that were not consumed are in the variable `args`.', brk.
        P cyan indent: 1 write: 'Program arguments\n',
          resetColor indent: 2 write: '-p : set the prompt\n',
          indent: 2 write: '-c : set the result color\n',
          indent: 2 write: '-h : show this help\n',
          indent: 2 write: '-f : evaluate file. many can be passed, evals in passed order\n',
          indent: 2 write: '-e : evaluate expression and exit, all args after the expr will be passed to the code as var `args`\n',
          indent: 2 write: '-enoquit : Do not quit the interpreter on errors\n',
          indent: 2 write: '-finstr : Enable instrumentation (advanced debug feature).\n',
          magenta indent: 1 write: 'Any other option will be consumed and dumped into the `args` array.', brk.
        P resetColor.
        Program exit.
    # when passed -p, get the next arg, and set the prompt to that.
    }, case: '-p' do: {
        args pop. #consume option..
        var value is Eval shiftArgs.
        (value isNil) ifTrue: { thisBlock error: '-p requires an arg.'. }.
        Eval setPrompt: value.
    # when passed -pc, get the next arg, and set the continuation prompt to that.
    }, case: '-pc' do: {
        args pop. #consume option..
        var value is Eval shiftArgs.
        (value isNil) ifTrue: { thisBlock error: '-pc requires an arg.'. }.
        Eval setContinuation: value.
    # when passed -c, get the next arg, and set the result color to that.
    }, case: '-c' do: {
        args pop. #consume option.
        var value is Eval shiftArgs.
        (value isNil) ifTrue: { thisBlock error: '-c requires an arg, valid arguments are: \n\t' + (((Eval allowedColors) split: '|') join: '\n\t'). }.
        Eval setColor: value.
    }, case: '-f' do: {
        args pop. #consume option.
        var file is Eval shiftArgs.
        (file isNil) ifTrue: { thisBlock error: '-f requires a file name.'. }.
        Eval enqueue: file.
    }, case: '-e' do: {
        args pop. #consume option..
        var value is Eval shiftArgs.
        (value isNil) ifTrue: { thisBlock error: '-e requires an argument.'. }.
        { ^(Eval argCount > 0). } whileTrue: { args push: Eval shiftArgs. }. #consume all other arguments.
        # if it ends in a dot, delete it.
        value findPattern: '(.*)\\.' do: {:p value is p at: 1.}.
        Pen write: (Eval evaluate: value).
        Program exit.
    }, case: '-enoquit' do: {
        args pop.
        Eval equit: True.
    }, case: '-finstr' do: {
        args pop.
        Reflect enableInstrumentation.
        Eval enableInstrumentation.
    }, switch. # do not consume any other option.
}.
Pen green. ?>Project Citron : The Programming Language (V<?. Pen write:(Reflect version) + ')' ,resetColor brk.
?>Eval Mode, parameters related to eval are in the Eval namespace.
run with '-h' to read the eval mode help.
<?.

Eval on: 'repl' do: {
  {^True.} whileTrue: {
    # break the repl when `end` is True.
    Eval break break.
    (Eval queueHasItem) ifTrue: {
      var item is Eval dequeue.
      Eval evaluateFile: item.
    }.
    Eval queueHasItem continue.
    Pen cyan write: (Eval prompt), resetColor.

    # get input, get rid of the trailing \n. If empty, don't bother evaluating.
    inp is Program waitForInput.
    (inp trim = '') continue.

    {^Eval queryState: inp.} whileFalse: {
      inp append: (inp countOf: '\'', even either: '\n' or: '') + ({
        Pen cyan write: Eval continuation * (1 + (inp countOf: '{') - (inp countOf: '}')), resetColor.
        ^Program waitForInput.
        } run).
      }.
    # if it ends in a dot, get rid of it.
    inp is inp trim.
    (inp at: (inp length - 1), = '.') ifTrue: {
      inp is inp from: 0 length: (inp length - 1).
    }.

    # Syntactic errors will not be passed to the eval. # TODO: handle that.
    'Pen %s write: (var ret is Eval evaluate: inp) toString' formatObjects: [(Eval color)], eval.
    Pen resetColor.
    __ is _.
    _ is ret.
    Eval pushHist: inp.
    #Broom sweep. #Keep the darn pointers in memory
    ret toString length > 0 ifTrue: { Pen brk. }.
  }.
}.

Eval repl.
